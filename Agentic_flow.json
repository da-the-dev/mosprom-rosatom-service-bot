{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ClassifyRequest",
            "id": "ClassifyRequest-h3OKt",
            "name": "tool_output",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-SD69D",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-ClassifyRequest-h3OKt{œdataTypeœ:œClassifyRequestœ,œidœ:œClassifyRequest-h3OKtœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}-Agent-SD69D{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "ClassifyRequest-h3OKt",
        "sourceHandle": "{œdataTypeœ:œClassifyRequestœ,œidœ:œClassifyRequest-h3OKtœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-SD69D",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "SystemAction",
            "id": "SystemAction-fVbYV",
            "name": "tool_output",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-SD69D",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-SystemAction-fVbYV{œdataTypeœ:œSystemActionœ,œidœ:œSystemAction-fVbYVœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}-Agent-SD69D{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "SystemAction-fVbYV",
        "sourceHandle": "{œdataTypeœ:œSystemActionœ,œidœ:œSystemAction-fVbYVœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-SD69D",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "KnowledgeBaseSearch",
            "id": "KnowledgeBaseSearch-WjuKu",
            "name": "tool_output",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-SD69D",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-KnowledgeBaseSearch-WjuKu{œdataTypeœ:œKnowledgeBaseSearchœ,œidœ:œKnowledgeBaseSearch-WjuKuœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}-Agent-SD69D{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "KnowledgeBaseSearch-WjuKu",
        "sourceHandle": "{œdataTypeœ:œKnowledgeBaseSearchœ,œidœ:œKnowledgeBaseSearch-WjuKuœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-SD69D",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "EscalateToHuman",
            "id": "EscalateToHuman-Tn5YM",
            "name": "tool_output",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-SD69D",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-EscalateToHuman-Tn5YM{œdataTypeœ:œEscalateToHumanœ,œidœ:œEscalateToHuman-Tn5YMœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}-Agent-SD69D{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "EscalateToHuman-Tn5YM",
        "sourceHandle": "{œdataTypeœ:œEscalateToHumanœ,œidœ:œEscalateToHuman-Tn5YMœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-SD69D",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "URLComponent",
            "id": "URLComponent-MKrOi",
            "name": "component_as_tool",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-SD69D",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__URLComponent-MKrOi{œdataTypeœ:œURLComponentœ,œidœ:œURLComponent-MKrOiœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}-Agent-SD69D{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "URLComponent-MKrOi",
        "sourceHandle": "{œdataTypeœ:œURLComponentœ,œidœ:œURLComponent-MKrOiœ,œnameœ:œcomponent_as_toolœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-SD69D",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Prompt Template",
            "id": "Prompt Template-KE2CE",
            "name": "prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "system_prompt",
            "id": "Agent-SD69D",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__Prompt Template-KE2CE{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-KE2CEœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-Agent-SD69D{œfieldNameœ:œsystem_promptœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "Prompt Template-KE2CE",
        "sourceHandle": "{œdataTypeœ:œPrompt Templateœ,œidœ:œPrompt Template-KE2CEœ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Agent-SD69D",
        "targetHandle": "{œfieldNameœ:œsystem_promptœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-rPhQw",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "Agent-SD69D",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "xy-edge__ChatInput-rPhQw{œdataTypeœ:œChatInputœ,œidœ:œChatInput-rPhQwœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-Agent-SD69D{œfieldNameœ:œinput_valueœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "selected": false,
        "source": "ChatInput-rPhQw",
        "sourceHandle": "{œdataTypeœ:œChatInputœ,œidœ:œChatInput-rPhQwœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}",
        "target": "Agent-SD69D",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Agent",
            "id": "Agent-SD69D",
            "name": "response",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-oaZFI",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__Agent-SD69D{œdataTypeœ:œAgentœ,œidœ:œAgent-SD69Dœ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}-ChatOutput-oaZFI{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-oaZFIœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "Agent-SD69D",
        "sourceHandle": "{œdataTypeœ:œAgentœ,œidœ:œAgent-SD69Dœ,œnameœ:œresponseœ,œoutput_typesœ:[œMessageœ]}",
        "target": "ChatOutput-oaZFI",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œChatOutput-oaZFIœ,œinputTypesœ:[œDataœ,œDataFrameœ,œMessageœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ToxicityCheck",
            "id": "CustomComponent-487Wh",
            "name": "tool_output",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-SD69D",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CustomComponent-487Wh{œdataTypeœ:œToxicityCheckœ,œidœ:œCustomComponent-487Whœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}-Agent-SD69D{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CustomComponent-487Wh",
        "sourceHandle": "{œdataTypeœ:œToxicityCheckœ,œidœ:œCustomComponent-487Whœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-SD69D",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "CheckRequestStatus",
            "id": "CustomComponent-wIqXI",
            "name": "tool_output",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-SD69D",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CustomComponent-wIqXI{œdataTypeœ:œCheckRequestStatusœ,œidœ:œCustomComponent-wIqXIœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}-Agent-SD69D{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CustomComponent-wIqXI",
        "sourceHandle": "{œdataTypeœ:œCheckRequestStatusœ,œidœ:œCustomComponent-wIqXIœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-SD69D",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "EmployeeInfo",
            "id": "CustomComponent-q1rbD",
            "name": "tool_output",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-SD69D",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CustomComponent-q1rbD{œdataTypeœ:œEmployeeInfoœ,œidœ:œCustomComponent-q1rbDœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}-Agent-SD69D{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CustomComponent-q1rbD",
        "sourceHandle": "{œdataTypeœ:œEmployeeInfoœ,œidœ:œCustomComponent-q1rbDœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-SD69D",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "SmartOrchestrationRouter",
            "id": "CustomComponent-qRuGK",
            "name": "tool_output",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-SD69D",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CustomComponent-qRuGK{œdataTypeœ:œSmartOrchestrationRouterœ,œidœ:œCustomComponent-qRuGKœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}-Agent-SD69D{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CustomComponent-qRuGK",
        "sourceHandle": "{œdataTypeœ:œSmartOrchestrationRouterœ,œidœ:œCustomComponent-qRuGKœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-SD69D",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ProcessingMonitor",
            "id": "CustomComponent-pznJO",
            "name": "tool_output",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-SD69D",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CustomComponent-pznJO{œdataTypeœ:œProcessingMonitorœ,œidœ:œCustomComponent-pznJOœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}-Agent-SD69D{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}",
        "selected": false,
        "source": "CustomComponent-pznJO",
        "sourceHandle": "{œdataTypeœ:œProcessingMonitorœ,œidœ:œCustomComponent-pznJOœ,œnameœ:œtool_outputœ,œoutput_typesœ:[œToolœ]}",
        "target": "Agent-SD69D",
        "targetHandle": "{œfieldNameœ:œtoolsœ,œidœ:œAgent-SD69Dœ,œinputTypesœ:[œToolœ],œtypeœ:œotherœ}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "EscalateToHuman-Tn5YM",
          "node": {
            "base_classes": [
              "Tool"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Передает обращение человеку-оператору",
            "display_name": "Escalate to Human Tool",
            "documentation": "",
            "edited": true,
            "field_order": [],
            "frozen": false,
            "icon": "user-circle",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Tool",
                "group_outputs": false,
                "hidden": null,
                "method": "build_tool",
                "name": "tool_output",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\r\nfrom langflow.io import Output, StrInput\r\nfrom langflow.schema.message import Message\r\nfrom langchain.tools import Tool\r\nfrom typing import Optional\r\nimport json\r\nfrom datetime import datetime\r\n\r\n\r\n# ============================================\r\n# TOOL 1: Эскалация на оператора (ОБЯЗАТЕЛЬНЫЙ)\r\n# ============================================\r\n\r\nclass EscalateToHumanTool(Component):\r\n    display_name = \"Escalate to Human Tool\"\r\n    description = \"Передает обращение человеку-оператору\"\r\n    icon = \"user-circle\"\r\n    name = \"EscalateToHuman\"\r\n    \r\n    outputs = [\r\n        Output(display_name=\"Tool\", name=\"tool_output\", method=\"build_tool\"),\r\n    ]\r\n\r\n    def escalate_to_human(self, reason: str) -> str:\r\n        \"\"\"\r\n        Функция эскалации на оператора\r\n        Принимает только reason как строку\r\n        \"\"\"\r\n        timestamp = datetime.now().isoformat()\r\n        \r\n        response = f\"\"\"\r\n╔════════════════════════════════════════╗\r\n║   ОБРАЩЕНИЕ ПЕРЕДАНО ОПЕРАТОРУ        ║\r\n╚════════════════════════════════════════╝\r\n\r\nПричина: {reason}\r\nВремя: {timestamp}\r\n\r\nОператор получил ваше обращение и скоро с вами свяжется.\r\nОбычное время ожидания: 5-10 минут.\r\n\r\nСпасибо за терпение! 🙏\r\n\"\"\"\r\n        \r\n        self.log(f\"Escalation triggered: {reason}\")\r\n        return response\r\n    \r\n    def build_tool(self) -> Tool:\r\n        \"\"\"\r\n        Создает Tool для Agent\r\n        \"\"\"\r\n        return Tool(\r\n            name=\"escalate_to_human\",\r\n            description=(\r\n                \"КРИТИЧЕСКИ ВАЖНЫЙ ИНСТРУМЕНТ! Используй этот инструмент когда: \"\r\n                \"1) Уверенность в ответе ниже 70%, \"\r\n                \"2) Пользователь явно просит связаться с оператором, \"\r\n                \"3) Вопрос требует человеческого суждения, \"\r\n                \"4) Не найдено решение в базе знаний, \"\r\n                \"5) Ситуация нестандартная или сложная. \"\r\n                \"Входной параметр: reason - причина эскалации (строка)\"\r\n            ),\r\n            func=self.escalate_to_human,\r\n        )"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "EscalateToHuman"
        },
        "dragging": false,
        "id": "EscalateToHuman-Tn5YM",
        "measured": {
          "height": 121,
          "width": 320
        },
        "position": {
          "x": 1358.8630288273625,
          "y": 668.386714332452
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "KnowledgeBaseSearch-WjuKu",
          "node": {
            "base_classes": [
              "Tool"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Поиск ответов в базе знаний через Qdrant с Yandex Embeddings",
            "display_name": "Knowledge Base Search Tool",
            "documentation": "",
            "edited": true,
            "field_order": [
              "qdrant_url",
              "collection_name",
              "qdrant_api_key",
              "yandex_api_key",
              "yandex_folder_id",
              "top_k",
              "score_threshold"
            ],
            "frozen": false,
            "icon": "database",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Tool",
                "group_outputs": false,
                "hidden": null,
                "method": "build_tool",
                "name": "tool_output",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\r\nfrom langflow.io import Output, StrInput, SecretStrInput, IntInput, FloatInput\r\nfrom langflow.schema.message import Message\r\nfrom langchain.tools import Tool\r\nfrom typing import Optional, List\r\nimport json\r\nimport requests\r\nfrom datetime import datetime\r\n\r\nclass KnowledgeBaseSearchTool(Component):\r\n    display_name = \"Knowledge Base Search Tool\"\r\n    description = \"Поиск ответов в базе знаний через Qdrant с Yandex Embeddings\"\r\n    icon = \"database\"\r\n    name = \"KnowledgeBaseSearch\"\r\n    \r\n    inputs = [\r\n        StrInput(\r\n            name=\"qdrant_url\",\r\n            display_name=\"Qdrant URL\",\r\n            value=\"http://localhost:6333\",\r\n            info=\"URL вашего Qdrant сервера\",\r\n        ),\r\n        StrInput(\r\n            name=\"collection_name\",\r\n            display_name=\"Collection Name\",\r\n            value=\"support_qa\",\r\n            info=\"Имя коллекции с QA данными\",\r\n        ),\r\n        SecretStrInput(\r\n            name=\"qdrant_api_key\",\r\n            display_name=\"Qdrant API Key\",\r\n            value=\"\",\r\n            info=\"API ключ для Qdrant (если требуется)\",\r\n        ),\r\n        SecretStrInput(\r\n            name=\"yandex_api_key\",\r\n            display_name=\"Yandex Cloud API Key\",\r\n            info=\"API ключ для Yandex Cloud (IAM токен или API ключ)\",\r\n            required=True,\r\n        ),\r\n        StrInput(\r\n            name=\"yandex_folder_id\",\r\n            display_name=\"Yandex Folder ID\",\r\n            info=\"ID каталога в Yandex Cloud\",\r\n            required=True,\r\n        ),\r\n        IntInput(\r\n            name=\"top_k\",\r\n            display_name=\"Top K Results\",\r\n            value=3,\r\n            info=\"Количество результатов для возврата\",\r\n        ),\r\n        FloatInput(\r\n            name=\"score_threshold\",\r\n            display_name=\"Score Threshold\",\r\n            value=0.7,\r\n            info=\"Минимальный порог релевантности (0-1)\",\r\n        ),\r\n    ]\r\n    \r\n    outputs = [\r\n        Output(display_name=\"Tool\", name=\"tool_output\", method=\"build_tool\"),\r\n    ]\r\n    \r\n    def get_yandex_embedding(self, text: str) -> List[float]:\r\n        \"\"\"\r\n        Получает эмбеддинг текста через Yandex Cloud API\r\n        \"\"\"\r\n        url = \"https://llm.api.cloud.yandex.net/foundationModels/v1/textEmbedding\"\r\n        \r\n        headers = {\r\n            \"Content-Type\": \"application/json\",\r\n            \"Authorization\": f\"Api-Key {self.yandex_api_key}\",\r\n            \"x-folder-id\": self.yandex_folder_id,\r\n        }\r\n        \r\n        payload = {\r\n            \"modelUri\": f\"emb://{self.yandex_folder_id}/text-search-query/latest\",\r\n            \"text\": text,\r\n        }\r\n        \r\n        try:\r\n            response = requests.post(url, headers=headers, json=payload, timeout=30)\r\n            response.raise_for_status()\r\n            \r\n            result = response.json()\r\n            embedding = result.get(\"embedding\", [])\r\n            \r\n            if not embedding:\r\n                raise ValueError(\"Получен пустой эмбеддинг от API\")\r\n            \r\n            self.log(f\"Получен эмбеддинг размерности: {len(embedding)}\")\r\n            return embedding\r\n            \r\n        except requests.exceptions.RequestException as e:\r\n            error_msg = f\"Ошибка запроса к Yandex API: {str(e)}\"\r\n            self.log(error_msg)\r\n            raise Exception(error_msg)\r\n        except Exception as e:\r\n            error_msg = f\"Ошибка при получении эмбеддинга: {str(e)}\"\r\n            self.log(error_msg)\r\n            raise Exception(error_msg)\r\n    \r\n    def format_results(self, query: str, results: List) -> str:\r\n        \"\"\"\r\n        Форматирует результаты поиска в читаемый вид\r\n        \"\"\"\r\n        if not results:\r\n            return f\"\"\"\r\n🔍 РЕЗУЛЬТАТЫ ПОИСКА В БАЗЕ ЗНАНИЙ\r\nЗапрос: \"{query}\"\r\n❌ Ничего не найдено\r\n\r\n💡 Попробуйте переформулировать вопрос или обратитесь к оператору.\r\n\"\"\"\r\n        \r\n        formatted = f\"\"\"\r\n🔍 РЕЗУЛЬТАТЫ ПОИСКА В БАЗЕ ЗНАНИЙ\r\nЗапрос: \"{query}\"\r\nНайдено: {len(results)} релевантных записей\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\"\"\"\r\n        \r\n        for idx, result in enumerate(results, 1):\r\n            score = result.score\r\n            payload = result.payload\r\n            \r\n            question = payload.get(\"question\", \"Нет вопроса\")\r\n            answer = payload.get(\"answer\", \"Нет ответа\")\r\n            category = payload.get(\"category\", \"Общее\")\r\n            \r\n            formatted += f\"\"\"\r\n📌 Результат #{idx} (Релевантность: {score:.2f})\r\nКатегория: {category}\r\nВопрос: {question}\r\nОтвет: {answer}\r\n\"\"\"\r\n        \r\n        formatted += \"\"\"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\"\"\"\r\n        \r\n        # Рекомендация по использованию\r\n        best_score = results[0].score if results else 0\r\n        if best_score >= 0.85:\r\n            formatted += \"💡 РЕКОМЕНДАЦИЯ: Высокая релевантность! Используй первый результат.\\n\"\r\n        elif best_score >= 0.7:\r\n            formatted += \"💡 РЕКОМЕНДАЦИЯ: Хорошая релевантность. Можно использовать первый результат.\\n\"\r\n        else:\r\n            formatted += \"⚠️ ВНИМАНИЕ: Низкая релевантность. Возможно, нужна помощь оператора.\\n\"\r\n        \r\n        return formatted\r\n    \r\n    def search_kb(self, query: str) -> str:\r\n        \"\"\"\r\n        Поиск в базе знаний с использованием векторного поиска\r\n        \"\"\"\r\n        try:\r\n            from qdrant_client import QdrantClient\r\n            from qdrant_client.models import Filter, FieldCondition, MatchValue\r\n            \r\n            # Подключение к Qdrant\r\n            client = QdrantClient(\r\n                url=self.qdrant_url,\r\n                api_key=self.qdrant_api_key if self.qdrant_api_key else None,\r\n                timeout=30,\r\n            )\r\n            \r\n            self.log(f\"Начинаю поиск для запроса: {query}\")\r\n            \r\n            # Получаем эмбеддинг запроса\r\n            query_vector = self.get_yandex_embedding(query)\r\n            \r\n            # Выполняем поиск в Qdrant\r\n            search_result = client.search(\r\n                collection_name=self.collection_name,\r\n                query_vector=query_vector,\r\n                limit=self.top_k,\r\n                score_threshold=self.score_threshold,\r\n                with_payload=True,\r\n            )\r\n            \r\n            self.log(f\"Найдено результатов: {len(search_result)}\")\r\n            \r\n            # Форматируем и возвращаем результаты\r\n            formatted_results = self.format_results(query, search_result)\r\n            return formatted_results\r\n            \r\n        except ImportError as e:\r\n            error_msg = f\"❌ Ошибка импорта библиотеки: {str(e)}\\nУстановите: pip install qdrant-client\"\r\n            self.log(error_msg)\r\n            return error_msg\r\n            \r\n        except Exception as e:\r\n            error_msg = f\"❌ Ошибка поиска в базе знаний: {str(e)}\"\r\n            self.log(error_msg)\r\n            return error_msg\r\n    \r\n    def build_tool(self) -> Tool:\r\n        return Tool(\r\n            name=\"search_knowledge_base\",\r\n            description=(\r\n                \"🔍 ОБЯЗАТЕЛЬНЫЙ инструмент для ВСЕХ вопросов о политиках компании, процедурах, инструкциях и корпоративных правилах. \"\r\n                \"Используй ВСЕГДА когда пользователь спрашивает: \"\r\n                \"- Как что-то сделать в системе компании (изменить график, создать заявку, настроить доступ) \"\r\n                \"- О правилах и политиках компании (отпуска, командировки, HR-процессы) \"\r\n                \"- О работе с корпоративными системами и сервисами \"\r\n                \"- О процедурах и регламентах компании \"\r\n                \"ВАЖНО: Даже если кажется, что знаешь ответ - ВСЕГДА проверь в базе знаний! \"\r\n                \"Компания может иметь специфические правила, отличающиеся от общепринятых. \"\r\n                \"Входной параметр: query (вопрос пользователя)\"\r\n            ),\r\n            func=self.search_kb,\r\n        )"
              },
              "collection_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Collection Name",
                "dynamic": false,
                "info": "Имя коллекции с QA данными",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "collection_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "support_qa"
              },
              "qdrant_api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Qdrant API Key",
                "dynamic": false,
                "info": "API ключ для Qdrant (если требуется)",
                "input_types": [],
                "load_from_db": false,
                "name": "qdrant_api_key",
                "password": true,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "qdrant_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Qdrant URL",
                "dynamic": false,
                "info": "URL вашего Qdrant сервера",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "qdrant_url",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "http://158.160.28.12:6333/"
              },
              "score_threshold": {
                "_input_type": "FloatInput",
                "advanced": false,
                "display_name": "Score Threshold",
                "dynamic": false,
                "info": "Минимальный порог релевантности (0-1)",
                "list": false,
                "list_add_label": "Add More",
                "name": "score_threshold",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "float",
                "value": 0.7
              },
              "top_k": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Top K Results",
                "dynamic": false,
                "info": "Количество результатов для возврата",
                "list": false,
                "list_add_label": "Add More",
                "name": "top_k",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 3
              },
              "yandex_api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Yandex Cloud API Key",
                "dynamic": false,
                "info": "API ключ для Yandex Cloud (IAM токен или API ключ)",
                "input_types": [],
                "load_from_db": false,
                "name": "yandex_api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "yandex_folder_id": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Yandex Folder ID",
                "dynamic": false,
                "info": "ID каталога в Yandex Cloud",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "yandex_folder_id",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "b1gbknonr2fm4ss0se7a"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "KnowledgeBaseSearch"
        },
        "dragging": false,
        "id": "KnowledgeBaseSearch-WjuKu",
        "measured": {
          "height": 711,
          "width": 320
        },
        "position": {
          "x": 900.838989133743,
          "y": 266.85908573837116
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "SystemAction-fVbYV",
          "node": {
            "base_classes": [
              "Tool"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Эмулирует выполнение действий в корпоративных системах",
            "display_name": "System Action Tool",
            "documentation": "",
            "edited": true,
            "field_order": [],
            "frozen": false,
            "icon": "settings",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Tool",
                "group_outputs": false,
                "hidden": null,
                "method": "build_tool",
                "name": "tool_output",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\r\nfrom langflow.io import Output, StrInput\r\nfrom langflow.schema.message import Message\r\nfrom langchain.tools import Tool\r\nfrom typing import Optional\r\nimport json\r\nfrom datetime import datetime\r\n\r\nclass SystemActionTool(Component):\r\n    display_name = \"System Action Tool\"\r\n    description = \"Эмулирует выполнение действий в корпоративных системах\"\r\n    icon = \"settings\"\r\n    name = \"SystemAction\"\r\n    \r\n    outputs = [\r\n        Output(display_name=\"Tool\", name=\"tool_output\", method=\"build_tool\"),\r\n    ]\r\n\r\n    def execute_action(self, action_description: str) -> str:\r\n        \"\"\"\r\n        Выполняет системное действие\r\n        Принимает описание действия как строку\r\n        \"\"\"\r\n        timestamp = datetime.now().strftime('%H:%M:%S')\r\n        \r\n        # Определяем тип действия из описания\r\n        action_lower = action_description.lower()\r\n        \r\n        if \"пароль\" in action_lower or \"password\" in action_lower:\r\n            return f\"\"\"\r\n✅ ПАРОЛЬ СБРОШЕН\r\n\r\nДействие: Сброс пароля\r\nНовый временный пароль отправлен на email\r\nСтатус: ВЫПОЛНЕНО\r\nВремя: {timestamp}\r\n\r\n⚠️ Пользователю необходимо сменить временный пароль при первом входе.\r\n\"\"\"\r\n        elif \"доступ\" in action_lower or \"access\" in action_lower:\r\n            return f\"\"\"\r\n✅ ДОСТУП ПРЕДОСТАВЛЕН\r\n\r\nДействие: Предоставление доступа\r\nУровень доступа: Read/Write\r\nСтатус: ВЫПОЛНЕНО\r\nВремя: {timestamp}\r\n\r\n✓ Изменения вступят в силу в течение 5 минут.\r\n\"\"\"\r\n        elif \"перезапуск\" in action_lower or \"restart\" in action_lower:\r\n            return f\"\"\"\r\n✅ СЕРВИС ПЕРЕЗАПУЩЕН\r\n\r\nДействие: Перезапуск сервиса\r\nВремя простоя: ~15 секунд\r\nСтатус: ВЫПОЛНЕНО\r\nВремя: {timestamp}\r\n\r\n✓ Сервис работает в штатном режиме.\r\n\"\"\"\r\n        elif \"разблок\" in action_lower or \"unlock\" in action_lower:\r\n            return f\"\"\"\r\n✅ АККАУНТ РАЗБЛОКИРОВАН\r\n\r\nДействие: Разблокировка аккаунта\r\nСчетчик попыток: Сброшен\r\nСтатус: АКТИВЕН\r\nВремя: {timestamp}\r\n\r\n✓ Пользователь может войти в систему.\r\n\"\"\"\r\n        else:\r\n            return f\"\"\"\r\n✅ ДЕЙСТВИЕ ВЫПОЛНЕНО\r\n\r\nОписание: {action_description}\r\nСтатус: ВЫПОЛНЕНО\r\nВремя: {timestamp}\r\n\r\n✓ Операция успешно завершена.\r\n\"\"\"\r\n    \r\n    def build_tool(self) -> Tool:\r\n        \"\"\"\r\n        Создает Tool для Agent\r\n        \"\"\"\r\n        return Tool(\r\n            name=\"execute_system_action\",\r\n            description=(\r\n                \"Выполняет действия в корпоративных информационных системах. \"\r\n                \"ВНИМАНИЕ: Используй только после подтверждения пользователем! \"\r\n                \"Доступные действия: сброс пароля, предоставление доступа, перезапуск сервиса, разблокировка аккаунта. \"\r\n                \"Входной параметр: action_description - описание действия которое нужно выполнить (строка)\"\r\n            ),\r\n            func=self.execute_action,\r\n        )"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "SystemAction"
        },
        "dragging": false,
        "id": "SystemAction-fVbYV",
        "measured": {
          "height": 137,
          "width": 320
        },
        "position": {
          "x": 1430.98667544403,
          "y": 320.6500131238286
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ClassifyRequest-h3OKt",
          "node": {
            "base_classes": [
              "Tool"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Классифицирует обращение пользователя по категории",
            "display_name": "Classify Request Tool",
            "documentation": "",
            "edited": true,
            "field_order": [],
            "frozen": false,
            "icon": "tag",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Tool",
                "group_outputs": false,
                "hidden": null,
                "method": "build_tool",
                "name": "tool_output",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\r\nfrom langflow.io import Output, StrInput\r\nfrom langflow.schema.message import Message\r\nfrom langchain.tools import Tool\r\nfrom typing import Optional\r\nimport json\r\nfrom datetime import datetime\r\nimport re\r\n\r\nclass ClassifyRequestTool(Component):\r\n    display_name = \"Classify Request Tool\"\r\n    description = \"Классифицирует обращение пользователя по категории\"\r\n    icon = \"tag\"\r\n    name = \"ClassifyRequest\"\r\n    \r\n    outputs = [\r\n        Output(display_name=\"Tool\", name=\"tool_output\", method=\"build_tool\"),\r\n    ]\r\n    \r\n    def classify(self, user_message: str) -> str:\r\n        \"\"\"\r\n        Классификация обращения с улучшенной логикой\r\n        \"\"\"\r\n        message_lower = user_message.lower()\r\n        \r\n        # Определяем категории с ключевыми словами и приоритетами\r\n        categories = {\r\n            \"SYSTEM_ACTION\": {\r\n                \"keywords\": [\r\n                    \"сбросить пароль\", \"сброс пароля\", \"создать учетную\", \r\n                    \"получить учетку\", \"выдать доступ\", \"разблокировать\",\r\n                    \"активировать\", \"деактивировать\", \"добавить пользователя\",\r\n                    \"удалить пользователя\", \"сбросить 2fa\", \"сбросить двухфакторную\"\r\n                ],\r\n                \"priority\": 1,  # Высший приоритет\r\n                \"require_confirmation\": True  # Требует подтверждения\r\n            },\r\n            \"HR_PROCESS\": {\r\n                \"keywords\": [\r\n                    \"график\", \"расписание\", \"смена\", \"отпуск\", \"больничный\", \r\n                    \"командировка\", \"увольнение\", \"перевод\", \"оформление\",\r\n                    \"декрет\", \"отгул\", \"выходной\", \"внести правки\", \"изменить график\",\r\n                    \"правки в график\", \"изменить расписание\"\r\n                ],\r\n                \"priority\": 2\r\n            },\r\n            \"EMPLOYEE_INFO\": {\r\n                \"keywords\": [\r\n                    \"моя информация\", \"мои данные\", \"остаток\", \"мой статус\",\r\n                    \"моё\", \"моя\", \"покажи\", \"сколько у меня\", \"мой график\",\r\n                    \"моя зарплата\", \"мои отпуска\"\r\n                ],\r\n                \"priority\": 2\r\n            },\r\n            \"REQUEST_CREATE\": {\r\n                \"keywords\": [\r\n                    \"создать заявку\", \"оформить заявку\", \"хочу создать\",\r\n                    \"нужно оформить\", \"подать заявление\", \"хочу взять\",\r\n                    \"создай заявку\", \"оформи заявку\"\r\n                ],\r\n                \"priority\": 2\r\n            },\r\n            \"REQUEST_STATUS\": {\r\n                \"keywords\": [\r\n                    \"статус заявки\", \"где моя заявка\", \"проверить заявку\",\r\n                    \"req-\", \"номер заявки\", \"статус заявления\"\r\n                ],\r\n                \"priority\": 2\r\n            },\r\n            \"TECHNICAL\": {\r\n                \"keywords\": [\r\n                    \"как сбросить\", \"как получить\", \"как создать\",\r\n                    \"не могу войти\", \"ошибка\", \"не работает\", \r\n                    \"проблема с\", \"что делать\", \"помогите\", \"как настроить\"\r\n                ],\r\n                \"priority\": 3\r\n            },\r\n            \"POLICY\": {\r\n                \"keywords\": [\r\n                    \"правила\", \"политика\", \"регламент\", \"можно ли\", \r\n                    \"разрешено ли\", \"положено\"\r\n                ],\r\n                \"priority\": 3\r\n            },\r\n            \"EXTERNAL_SEARCH\": {\r\n                \"keywords\": [\r\n                    \"найди в интернете\", \"что пишут\", \"погугли\", \r\n                    \"поищи в сети\", \"найди информацию\"\r\n                ],\r\n                \"priority\": 2\r\n            }\r\n        }\r\n        \r\n        detected_category = \"GENERAL\"\r\n        confidence = 0.5\r\n        max_matches = 0\r\n        require_confirmation = False\r\n        \r\n        # КРИТИЧЕСКИ ВАЖНО: Различаем \"сбросить пароль\" vs \"как сбросить пароль\"\r\n        has_how_question = any(word in message_lower for word in [\"как\", \"what\", \"how\", \"каким образом\"])\r\n        has_action_verb = any(word in message_lower for word in [\"сбросить\", \"создать\", \"выдать\", \"разблокировать\", \"активировать\"])\r\n        \r\n        # Если есть \"как\" + глагол действия → это вопрос (TECHNICAL), а не действие\r\n        if has_how_question and has_action_verb:\r\n            detected_category = \"TECHNICAL\"\r\n            confidence = 0.85\r\n            self.log(f\"Detected HOW question: {message_lower}\")\r\n        else:\r\n            # Проверяем категории по приоритету\r\n            for category, config in sorted(categories.items(), key=lambda x: x[1][\"priority\"]):\r\n                matches = 0\r\n                for keyword in config[\"keywords\"]:\r\n                    if keyword in message_lower:\r\n                        matches += 1\r\n                \r\n                if matches > max_matches:\r\n                    max_matches = matches\r\n                    detected_category = category\r\n                    confidence = min(0.95, 0.6 + (matches * 0.15))\r\n                    require_confirmation = config.get(\"require_confirmation\", False)\r\n                    break  # Берем первую найденную категорию с высшим приоритетом\r\n        \r\n        # Если ничего не найдено, остается GENERAL с низкой уверенностью\r\n        if detected_category == \"GENERAL\":\r\n            confidence = 0.5\r\n        \r\n        # Формируем результат\r\n        priority_level = \"Высокий\" if confidence > 0.8 else \"Средний\" if confidence > 0.6 else \"Низкий\"\r\n        recommendation = \"\"\r\n        \r\n        if confidence > 0.7:\r\n            recommendation = \"✓ Высокая уверенность - обработка автоматически\"\r\n        else:\r\n            recommendation = \"⚠️ Низкая уверенность - рекомендуется эскалация\"\r\n        \r\n        if require_confirmation:\r\n            recommendation += \"\\n⚠️ Требуется подтверждение пользователя перед выполнением действия!\"\r\n        \r\n        result = f\"\"\"\r\n📋 КЛАССИФИКАЦИЯ ОБРАЩЕНИЯ\r\n\r\nКатегория: {detected_category}\r\nУверенность: {confidence:.0%}\r\nПриоритет: {priority_level}\r\n\r\nРекомендация: {recommendation}\r\n\"\"\"\r\n        \r\n        self.log(f\"Classification: {detected_category} (confidence: {confidence:.2f}, matches: {max_matches})\")\r\n        self.log(f\"Original message: {user_message}\")\r\n        \r\n        return result\r\n    \r\n    def build_tool(self) -> Tool:\r\n        \"\"\"\r\n        Создает Tool для Agent\r\n        \"\"\"\r\n        return Tool(\r\n            name=\"classify_request\",\r\n            description=(\r\n                \"⚠️ ОБЯЗАТЕЛЬНЫЙ ПЕРВЫЙ инструмент для КАЖДОГО запроса! ⚠️\\n\\n\"\r\n                \"Классифицирует обращение пользователя и определяет правильную стратегию обработки.\\n\\n\"\r\n                \"Категории:\\n\"\r\n                \"- HR_PROCESS: вопросы о графиках, отпусках, больничных\\n\"\r\n                \"- EMPLOYEE_INFO: запросы информации о себе\\n\"\r\n                \"- REQUEST_CREATE: создание заявок\\n\"\r\n                \"- REQUEST_STATUS: проверка статуса заявок\\n\"\r\n                \"- SYSTEM_ACTION: выполнение действий (сброс пароля, создание учеток) - требует подтверждения!\\n\"\r\n                \"- TECHNICAL: вопросы 'как сделать', технические проблемы\\n\"\r\n                \"- POLICY: вопросы о правилах и политиках\\n\"\r\n                \"- EXTERNAL_SEARCH: поиск в интернете\\n\"\r\n                \"- GENERAL: общие вопросы\\n\\n\"\r\n                \"ВАЖНО: Различает 'сбросить пароль' (SYSTEM_ACTION) и 'как сбросить пароль' (TECHNICAL)\\n\\n\"\r\n                \"Входной параметр: user_message - текст обращения пользователя (строка)\"\r\n            ),\r\n            func=self.classify,\r\n        )"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ClassifyRequest"
        },
        "dragging": false,
        "id": "ClassifyRequest-h3OKt",
        "measured": {
          "height": 137,
          "width": 320
        },
        "position": {
          "x": 1865.7810516605755,
          "y": 27.87277454092439
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Agent-SD69D",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Define the agent's instructions, then enter a task to complete using tools.",
            "display_name": "Agent",
            "documentation": "https://docs.langflow.org/agents",
            "edited": true,
            "field_order": [
              "agent_llm",
              "max_tokens",
              "model_kwargs",
              "json_mode",
              "model_name",
              "openai_api_base",
              "api_key",
              "temperature",
              "seed",
              "max_retries",
              "timeout",
              "custom_base_url",
              "custom_api_key",
              "custom_model_name",
              "system_prompt",
              "n_messages",
              "tools",
              "input_value",
              "handle_parsing_errors",
              "verbose",
              "max_iterations",
              "agent_description",
              "add_current_date_tool"
            ],
            "frozen": false,
            "icon": "bot",
            "last_updated": "2025-10-18T11:31:20.025Z",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Response",
                "group_outputs": false,
                "hidden": null,
                "method": "message_response",
                "name": "response",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "add_current_date_tool": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Current Date",
                "dynamic": false,
                "info": "If true, will add a tool to the agent that returns the current date.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "add_current_date_tool",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "agent_description": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Agent Description [Deprecated]",
                "dynamic": false,
                "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "agent_description",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "A helpful assistant with access to the following tools:"
              },
              "agent_llm": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Language Model",
                "dynamic": false,
                "external_options": {},
                "info": "",
                "input_types": [
                  "LanguageModel"
                ],
                "name": "agent_llm",
                "options": [
                  "Anthropic",
                  "Google Generative AI",
                  "OpenAI",
                  "Custom"
                ],
                "options_metadata": [
                  {
                    "icon": "Anthropic"
                  },
                  {
                    "icon": "GoogleGenerativeAI"
                  },
                  {
                    "icon": "OpenAI"
                  },
                  {
                    "icon": "brain"
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Custom"
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "input_types": [],
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langchain_core.tools import StructuredTool\r\n\r\nfrom langflow.base.agents.agent import LCToolsAgentComponent\r\nfrom langflow.base.agents.events import ExceptionWithMessageError\r\nfrom langflow.base.models.model_input_constants import (\r\n    ALL_PROVIDER_FIELDS,\r\n    MODEL_DYNAMIC_UPDATE_FIELDS,\r\n    MODEL_PROVIDERS,\r\n    MODEL_PROVIDERS_DICT,\r\n    MODELS_METADATA,\r\n)\r\nfrom langflow.base.models.model_utils import get_model_name\r\nfrom langflow.components.helpers.current_date import CurrentDateComponent\r\nfrom langflow.components.helpers.memory import MemoryComponent\r\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\r\nfrom langflow.custom.custom_component.component import _get_component_toolkit\r\nfrom langflow.custom.utils import update_component_build_config\r\nfrom langflow.field_typing import Tool\r\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MultilineInput, Output, SecretStrInput, StrInput\r\nfrom langflow.logging import logger\r\nfrom langflow.schema.dotdict import dotdict\r\nfrom langflow.schema.message import Message\r\n\r\n\r\ndef set_advanced_true(component_input):\r\n    component_input.advanced = True\r\n    return component_input\r\n\r\n\r\n# Динамически создаем список провайдеров из MODEL_PROVIDERS_DICT\r\nMODEL_PROVIDERS_LIST = [\r\n    provider for provider in [\"Anthropic\", \"Google Generative AI\", \"Groq\", \"OpenAI\"]\r\n    if provider in MODEL_PROVIDERS_DICT\r\n]\r\n\r\n# Если список пуст, используем все доступные провайдеры\r\nif not MODEL_PROVIDERS_LIST:\r\n    MODEL_PROVIDERS_LIST = list(MODEL_PROVIDERS_DICT.keys())\r\n\r\n\r\nclass AgentComponent(ToolCallingAgentComponent):\r\n    display_name: str = \"Agent\"\r\n    description: str = \"Define the agent's instructions, then enter a task to complete using tools.\"\r\n    documentation: str = \"https://docs.langflow.org/agents\"\r\n    icon = \"bot\"\r\n    beta = False\r\n    name = \"Agent\"\r\n\r\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\r\n\r\n    # Определяем провайдера по умолчанию и входы заранее\r\n    _default_provider = \"OpenAI\" if \"OpenAI\" in MODEL_PROVIDERS_LIST else (MODEL_PROVIDERS_LIST[0] if MODEL_PROVIDERS_LIST else \"Custom\")\r\n    _default_inputs = MODEL_PROVIDERS_DICT[_default_provider][\"inputs\"] if _default_provider in MODEL_PROVIDERS_DICT else []\r\n    _options_metadata = [MODELS_METADATA[key] for key in MODEL_PROVIDERS_LIST if key in MODELS_METADATA] + [{\"icon\": \"brain\"}]\r\n\r\n    inputs = [\r\n        DropdownInput(\r\n            name=\"agent_llm\",\r\n            display_name=\"Model Provider\",\r\n            info=\"The provider of the language model that the agent will use to generate responses.\",\r\n            options=[*MODEL_PROVIDERS_LIST, \"Custom\"],\r\n            value=_default_provider,\r\n            real_time_refresh=True,\r\n            input_types=[],\r\n            options_metadata=_options_metadata,\r\n        ),\r\n        *_default_inputs,\r\n        # Поля для кастомного OpenAI-совместимого API (YandexGPT)\r\n        StrInput(\r\n            name=\"custom_base_url\",\r\n            display_name=\"Custom Base URL\",\r\n            info=\"Base URL for OpenAI-compatible API (e.g., https://llm.api.cloud.yandex.net/v1 for YandexGPT)\",\r\n            value=\"\",\r\n            advanced=True,\r\n        ),\r\n        SecretStrInput(\r\n            name=\"custom_api_key\",\r\n            display_name=\"Custom API Key\",\r\n            info=\"API key for custom OpenAI-compatible endpoint\",\r\n            value=\"\",\r\n            advanced=True,\r\n        ),\r\n        StrInput(\r\n            name=\"custom_model_name\",\r\n            display_name=\"Custom Model Name\",\r\n            info=\"Model identifier (e.g., gpt://b1gbknonr2fm4ss0se7a/qwen3-235b-a22b-fp8/latest for YandexGPT)\",\r\n            value=\"\",\r\n            advanced=True,\r\n        ),\r\n        MultilineInput(\r\n            name=\"system_prompt\",\r\n            display_name=\"Agent Instructions\",\r\n            info=\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\",\r\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\r\n            advanced=False,\r\n        ),\r\n        IntInput(\r\n            name=\"n_messages\",\r\n            display_name=\"Number of Chat History Messages\",\r\n            value=100,\r\n            info=\"Number of chat history messages to retrieve.\",\r\n            advanced=True,\r\n            show=True,\r\n        ),\r\n        *LCToolsAgentComponent._base_inputs,\r\n        BoolInput(\r\n            name=\"add_current_date_tool\",\r\n            display_name=\"Current Date\",\r\n            advanced=True,\r\n            info=\"If true, will add a tool to the agent that returns the current date.\",\r\n            value=True,\r\n        ),\r\n    ]\r\n    outputs = [Output(name=\"response\", display_name=\"Response\", method=\"message_response\")]\r\n\r\n    async def message_response(self) -> Message:\r\n        try:\r\n            # Get LLM model and validate\r\n            llm_model, display_name = self.get_llm()\r\n            if llm_model is None:\r\n                msg = \"No language model selected. Please choose a model to proceed.\"\r\n                raise ValueError(msg)\r\n            self.model_name = get_model_name(llm_model, display_name=display_name)\r\n\r\n            # Get memory data\r\n            self.chat_history = await self.get_memory_data()\r\n            if isinstance(self.chat_history, Message):\r\n                self.chat_history = [self.chat_history]\r\n\r\n            # Add current date tool if enabled\r\n            if self.add_current_date_tool:\r\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\r\n                    self.tools = []\r\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\r\n                if not isinstance(current_date_tool, StructuredTool):\r\n                    msg = \"CurrentDateComponent must be converted to a StructuredTool\"\r\n                    raise TypeError(msg)\r\n                self.tools.append(current_date_tool)\r\n\r\n            # Set up and run agent\r\n            self.set(\r\n                llm=llm_model,\r\n                tools=self.tools or [],\r\n                chat_history=self.chat_history,\r\n                input_value=self.input_value,\r\n                system_prompt=self.system_prompt,\r\n            )\r\n            agent = self.create_agent_runnable()\r\n            return await self.run_agent(agent)\r\n\r\n        except (ValueError, TypeError, KeyError) as e:\r\n            logger.error(f\"{type(e).__name__}: {e!s}\")\r\n            raise\r\n        except ExceptionWithMessageError as e:\r\n            logger.error(f\"ExceptionWithMessageError occurred: {e}\")\r\n            raise\r\n        except Exception as e:\r\n            logger.error(f\"Unexpected error: {e!s}\")\r\n            raise\r\n\r\n    async def get_memory_data(self):\r\n        messages = (\r\n            await MemoryComponent(**self.get_base_args())\r\n            .set(session_id=self.graph.session_id, order=\"Ascending\", n_messages=self.n_messages)\r\n            .retrieve_messages()\r\n        )\r\n        return [\r\n            message for message in messages if getattr(message, \"id\", None) != getattr(self.input_value, \"id\", None)\r\n        ]\r\n\r\n    def get_llm(self):\r\n        if not isinstance(self.agent_llm, str):\r\n            return self.agent_llm, None\r\n    \r\n        try:\r\n            # Обработка Custom провайдера (YandexGPT и другие OpenAI-совместимые API)\r\n            if self.agent_llm == \"Custom\":\r\n                # Проверяем, что все необходимые поля заполнены\r\n                if not self.custom_base_url or not self.custom_api_key or not self.custom_model_name:\r\n                    msg = \"For Custom provider, please fill in: Custom Base URL, Custom API Key, and Custom Model Name\"\r\n                    raise ValueError(msg)\r\n                \r\n                # Импортируем напрямую ChatOpenAI из langchain\r\n                from langchain_openai import ChatOpenAI\r\n                \r\n                # Создаем модель напрямую, без использования компонента OpenAI\r\n                # Это позволит обойти любые проверки региона в компоненте\r\n                model = ChatOpenAI(\r\n                    base_url=self.custom_base_url,\r\n                    api_key=self.custom_api_key,\r\n                    model=self.custom_model_name,  # используем 'model', а не 'model_name'\r\n                    temperature=0.1,\r\n                    max_retries=2,\r\n                    timeout=60,\r\n                    # Добавляем параметры для обхода проверок\r\n                    default_headers={\r\n                        \"User-Agent\": \"langflow-custom-client\"\r\n                    }\r\n                )\r\n                \r\n                return model, \"Custom OpenAI-compatible API\"\r\n            \r\n            # Обработка стандартных провайдеров (OpenAI, Anthropic и т.д.)\r\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\r\n            if not provider_info:\r\n                if self.agent_llm in MODEL_PROVIDERS_LIST:\r\n                    msg = f\"Provider '{self.agent_llm}' is available but not properly configured in MODEL_PROVIDERS_DICT\"\r\n                else:\r\n                    msg = f\"Invalid model provider: {self.agent_llm}. Available providers: {', '.join(MODEL_PROVIDERS_LIST)}\"\r\n                raise ValueError(msg)\r\n    \r\n            component_class = provider_info.get(\"component_class\")\r\n            display_name = component_class.display_name if component_class else None\r\n            inputs = provider_info.get(\"inputs\", [])\r\n            prefix = provider_info.get(\"prefix\", \"\")\r\n    \r\n            return self._build_llm_model(component_class, inputs, prefix), display_name\r\n    \r\n        except Exception as e:\r\n            logger.error(f\"Error building {self.agent_llm} language model: {e!s}\")\r\n            msg = f\"Failed to initialize language model: {e!s}\"\r\n            raise ValueError(msg) from e\r\n\r\n    def set_component_params(self, component):\r\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\r\n        if provider_info:\r\n            inputs = provider_info.get(\"inputs\", [])\r\n            prefix = provider_info.get(\"prefix\", \"\")\r\n            model_kwargs = {input_.name: getattr(self, f\"{prefix}{input_.name}\") for input_ in inputs if hasattr(self, f\"{prefix}{input_.name}\")}\r\n\r\n            return component.set(**model_kwargs)\r\n        return component\r\n\r\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\r\n        \"\"\"Delete specified fields from build_config.\"\"\"\r\n        for field in fields:\r\n            build_config.pop(field, None)\r\n\r\n    def update_input_types(self, build_config: dotdict) -> dotdict:\r\n        \"\"\"Update input types for all fields in build_config.\"\"\"\r\n        for key, value in build_config.items():\r\n            if isinstance(value, dict):\r\n                if value.get(\"input_types\") is None:\r\n                    build_config[key][\"input_types\"] = []\r\n            elif hasattr(value, \"input_types\") and value.input_types is None:\r\n                value.input_types = []\r\n        return build_config\r\n\r\n    async def update_build_config(\r\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\r\n    ) -> dotdict:\r\n        if field_name in (\"agent_llm\",):\r\n            build_config[\"agent_llm\"][\"value\"] = field_value\r\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\r\n            if provider_info:\r\n                component_class = provider_info.get(\"component_class\")\r\n                if component_class and hasattr(component_class, \"update_build_config\"):\r\n                    build_config = await update_component_build_config(\r\n                        component_class, build_config, field_value, \"model_name\"\r\n                    )\r\n\r\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\r\n                provider: (\r\n                    MODEL_PROVIDERS_DICT[provider][\"fields\"],\r\n                    [\r\n                        MODEL_PROVIDERS_DICT[other_provider][\"fields\"]\r\n                        for other_provider in MODEL_PROVIDERS_DICT\r\n                        if other_provider != provider\r\n                    ],\r\n                )\r\n                for provider in MODEL_PROVIDERS_DICT\r\n            }\r\n            if field_value in provider_configs:\r\n                fields_to_add, fields_to_delete = provider_configs[field_value]\r\n\r\n                for fields in fields_to_delete:\r\n                    self.delete_fields(build_config, fields)\r\n\r\n                if field_value == \"OpenAI\" and not any(field in build_config for field in fields_to_add):\r\n                    build_config.update(fields_to_add)\r\n                else:\r\n                    build_config.update(fields_to_add)\r\n                build_config[\"agent_llm\"][\"input_types\"] = []\r\n            elif field_value == \"Custom\":\r\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\r\n                custom_component = DropdownInput(\r\n                    name=\"agent_llm\",\r\n                    display_name=\"Language Model\",\r\n                    options=[*sorted(MODEL_PROVIDERS), \"Custom\"],\r\n                    value=\"Custom\",\r\n                    real_time_refresh=True,\r\n                    input_types=[\"LanguageModel\"],\r\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys()) if key in MODELS_METADATA]\r\n                    + [{\"icon\": \"brain\"}],\r\n                )\r\n                build_config.update({\"agent_llm\": custom_component.to_dict()})\r\n            build_config = self.update_input_types(build_config)\r\n\r\n            default_keys = [\r\n                \"code\",\r\n                \"_type\",\r\n                \"agent_llm\",\r\n                \"tools\",\r\n                \"input_value\",\r\n                \"add_current_date_tool\",\r\n                \"system_prompt\",\r\n                \"agent_description\",\r\n                \"max_iterations\",\r\n                \"handle_parsing_errors\",\r\n                \"verbose\",\r\n            ]\r\n            missing_keys = [key for key in default_keys if key not in build_config]\r\n            if missing_keys:\r\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\r\n                raise ValueError(msg)\r\n        if (\r\n            isinstance(self.agent_llm, str)\r\n            and self.agent_llm in MODEL_PROVIDERS_DICT\r\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\r\n        ):\r\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\r\n            if provider_info:\r\n                component_class = provider_info.get(\"component_class\")\r\n                component_class = self.set_component_params(component_class)\r\n                prefix = provider_info.get(\"prefix\", \"\")\r\n                if component_class and hasattr(component_class, \"update_build_config\"):\r\n                    if isinstance(field_name, str) and isinstance(prefix, str):\r\n                        field_name = field_name.replace(prefix, \"\")\r\n                    build_config = await update_component_build_config(\r\n                        component_class, build_config, field_value, \"model_name\"\r\n                    )\r\n        return dotdict({k: v.to_dict() if hasattr(v, \"to_dict\") else v for k, v in build_config.items()})\r\n\r\n    async def _get_tools(self) -> list[Tool]:\r\n        component_toolkit = _get_component_toolkit()\r\n        tools_names = self._build_tools_names()\r\n        agent_description = self.get_tool_description()\r\n        description = f\"{agent_description}{tools_names}\"\r\n        tools = component_toolkit(component=self).get_tools(\r\n            tool_name=\"Call_Agent\", tool_description=description, callbacks=self.get_langchain_callbacks()\r\n        )\r\n        if hasattr(self, \"tools_metadata\"):\r\n            tools = component_toolkit(component=self, metadata=self.tools_metadata).update_tools_metadata(tools=tools)\r\n        return tools"
              },
              "custom_api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "Custom API Key",
                "dynamic": false,
                "info": "API key for custom OpenAI-compatible endpoint",
                "input_types": [],
                "load_from_db": false,
                "name": "custom_api_key",
                "password": true,
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "custom_base_url": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Custom Base URL",
                "dynamic": false,
                "info": "Base URL for OpenAI-compatible API (e.g., https://llm.api.cloud.yandex.net/v1 for YandexGPT)",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "custom_base_url",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "https://llm.api.cloud.yandex.net/v1"
              },
              "custom_model_name": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Custom Model Name",
                "dynamic": false,
                "info": "Model identifier (e.g., gpt://b1gbknonr2fm4ss0se7a/qwen3-235b-a22b-fp8/latest for YandexGPT)",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "custom_model_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gpt://b1gbknonr2fm4ss0se7a/gpt-oss-20b/latest"
              },
              "handle_parsing_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Handle Parse Errors",
                "dynamic": false,
                "info": "Should the Agent fix errors when reading user input for better processing?",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "handle_parsing_errors",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "input_value": {
                "_input_type": "MessageInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input provided by the user for the agent to process.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 15
              },
              "n_messages": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Chat History Messages",
                "dynamic": false,
                "info": "Number of chat history messages to retrieve.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "n_messages",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 100
              },
              "system_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Agent Instructions",
                "dynamic": false,
                "info": "System Prompt: Initial instructions and context provided to guide the agent's behavior.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_prompt",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "You are a helpful assistant that can use tools to answer questions and perform tasks."
              },
              "tools": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Tools",
                "dynamic": false,
                "info": "These are the tools that the agent can use to help with tasks.",
                "input_types": [
                  "Tool"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "tools",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Verbose",
                "dynamic": false,
                "info": "",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Agent"
        },
        "dragging": false,
        "id": "Agent-SD69D",
        "measured": {
          "height": 673,
          "width": 320
        },
        "position": {
          "x": 3949.632166174068,
          "y": -343.5994306403219
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "URLComponent-MKrOi",
          "node": {
            "base_classes": [
              "DataFrame",
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Fetch content from one or more web pages, following links recursively.",
            "display_name": "URL",
            "documentation": "https://docs.langflow.org/components-data#url",
            "edited": false,
            "field_order": [
              "urls",
              "max_depth",
              "prevent_outside",
              "use_async",
              "format",
              "timeout",
              "headers",
              "filter_text_html",
              "continue_on_failure",
              "check_response_status",
              "autoset_encoding"
            ],
            "frozen": false,
            "icon": "layout-template",
            "last_updated": "2025-10-19T00:13:29.348Z",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Toolset",
                "group_outputs": false,
                "hidden": null,
                "method": "to_toolkit",
                "name": "component_as_tool",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "autoset_encoding": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Autoset Encoding",
                "dynamic": false,
                "info": "If enabled, automatically sets the encoding of the request.",
                "list": false,
                "list_add_label": "Add More",
                "name": "autoset_encoding",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "check_response_status": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Check Response Status",
                "dynamic": false,
                "info": "If enabled, checks the response status of the request.",
                "list": false,
                "list_add_label": "Add More",
                "name": "check_response_status",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import re\n\nimport requests\nfrom bs4 import BeautifulSoup\nfrom langchain_community.document_loaders import RecursiveUrlLoader\n\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.field_typing.range_spec import RangeSpec\nfrom langflow.helpers.data import safe_convert\nfrom langflow.io import BoolInput, DropdownInput, IntInput, MessageTextInput, Output, SliderInput, TableInput\nfrom langflow.logging.logger import logger\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.services.deps import get_settings_service\n\n# Constants\nDEFAULT_TIMEOUT = 30\nDEFAULT_MAX_DEPTH = 1\nDEFAULT_FORMAT = \"Text\"\nURL_REGEX = re.compile(\n    r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n    re.IGNORECASE,\n)\n\n\nclass URLComponent(Component):\n    \"\"\"A component that loads and parses content from web pages recursively.\n\n    This component allows fetching content from one or more URLs, with options to:\n    - Control crawl depth\n    - Prevent crawling outside the root domain\n    - Use async loading for better performance\n    - Extract either raw HTML or clean text\n    - Configure request headers and timeouts\n    \"\"\"\n\n    display_name = \"URL\"\n    description = \"Fetch content from one or more web pages, following links recursively.\"\n    documentation: str = \"https://docs.langflow.org/components-data#url\"\n    icon = \"layout-template\"\n    name = \"URLComponent\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"urls\",\n            display_name=\"URLs\",\n            info=\"Enter one or more URLs to crawl recursively, by clicking the '+' button.\",\n            is_list=True,\n            tool_mode=True,\n            placeholder=\"Enter a URL...\",\n            list_add_label=\"Add URL\",\n            input_types=[],\n        ),\n        SliderInput(\n            name=\"max_depth\",\n            display_name=\"Depth\",\n            info=(\n                \"Controls how many 'clicks' away from the initial page the crawler will go:\\n\"\n                \"- depth 1: only the initial page\\n\"\n                \"- depth 2: initial page + all pages linked directly from it\\n\"\n                \"- depth 3: initial page + direct links + links found on those direct link pages\\n\"\n                \"Note: This is about link traversal, not URL path depth.\"\n            ),\n            value=DEFAULT_MAX_DEPTH,\n            range_spec=RangeSpec(min=1, max=5, step=1),\n            required=False,\n            min_label=\" \",\n            max_label=\" \",\n            min_label_icon=\"None\",\n            max_label_icon=\"None\",\n            # slider_input=True\n        ),\n        BoolInput(\n            name=\"prevent_outside\",\n            display_name=\"Prevent Outside\",\n            info=(\n                \"If enabled, only crawls URLs within the same domain as the root URL. \"\n                \"This helps prevent the crawler from going to external websites.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"use_async\",\n            display_name=\"Use Async\",\n            info=(\n                \"If enabled, uses asynchronous loading which can be significantly faster \"\n                \"but might use more system resources.\"\n            ),\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"format\",\n            display_name=\"Output Format\",\n            info=\"Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.\",\n            options=[\"Text\", \"HTML\"],\n            value=DEFAULT_FORMAT,\n            advanced=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            info=\"Timeout for the request in seconds.\",\n            value=DEFAULT_TIMEOUT,\n            required=False,\n            advanced=True,\n        ),\n        TableInput(\n            name=\"headers\",\n            display_name=\"Headers\",\n            info=\"The headers to send with the request\",\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Header\",\n                    \"type\": \"str\",\n                    \"description\": \"Header name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"type\": \"str\",\n                    \"description\": \"Header value\",\n                },\n            ],\n            value=[{\"key\": \"User-Agent\", \"value\": get_settings_service().settings.user_agent}],\n            advanced=True,\n            input_types=[\"DataFrame\"],\n        ),\n        BoolInput(\n            name=\"filter_text_html\",\n            display_name=\"Filter Text/HTML\",\n            info=\"If enabled, filters out text/css content type from the results.\",\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"continue_on_failure\",\n            display_name=\"Continue on Failure\",\n            info=\"If enabled, continues crawling even if some requests fail.\",\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"check_response_status\",\n            display_name=\"Check Response Status\",\n            info=\"If enabled, checks the response status of the request.\",\n            value=False,\n            required=False,\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"autoset_encoding\",\n            display_name=\"Autoset Encoding\",\n            info=\"If enabled, automatically sets the encoding of the request.\",\n            value=True,\n            required=False,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Extracted Pages\", name=\"page_results\", method=\"fetch_content\"),\n        Output(display_name=\"Raw Content\", name=\"raw_results\", method=\"fetch_content_as_message\", tool_mode=False),\n    ]\n\n    @staticmethod\n    def validate_url(url: str) -> bool:\n        \"\"\"Validates if the given string matches URL pattern.\n\n        Args:\n            url: The URL string to validate\n\n        Returns:\n            bool: True if the URL is valid, False otherwise\n        \"\"\"\n        return bool(URL_REGEX.match(url))\n\n    def ensure_url(self, url: str) -> str:\n        \"\"\"Ensures the given string is a valid URL.\n\n        Args:\n            url: The URL string to validate and normalize\n\n        Returns:\n            str: The normalized URL\n\n        Raises:\n            ValueError: If the URL is invalid\n        \"\"\"\n        url = url.strip()\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"https://\" + url\n\n        if not self.validate_url(url):\n            msg = f\"Invalid URL: {url}\"\n            raise ValueError(msg)\n\n        return url\n\n    def _create_loader(self, url: str) -> RecursiveUrlLoader:\n        \"\"\"Creates a RecursiveUrlLoader instance with the configured settings.\n\n        Args:\n            url: The URL to load\n\n        Returns:\n            RecursiveUrlLoader: Configured loader instance\n        \"\"\"\n        headers_dict = {header[\"key\"]: header[\"value\"] for header in self.headers if header[\"value\"] is not None}\n        extractor = (lambda x: x) if self.format == \"HTML\" else (lambda x: BeautifulSoup(x, \"lxml\").get_text())\n\n        return RecursiveUrlLoader(\n            url=url,\n            max_depth=self.max_depth,\n            prevent_outside=self.prevent_outside,\n            use_async=self.use_async,\n            extractor=extractor,\n            timeout=self.timeout,\n            headers=headers_dict,\n            check_response_status=self.check_response_status,\n            continue_on_failure=self.continue_on_failure,\n            base_url=url,  # Add base_url to ensure consistent domain crawling\n            autoset_encoding=self.autoset_encoding,  # Enable automatic encoding detection\n            exclude_dirs=[],  # Allow customization of excluded directories\n            link_regex=None,  # Allow customization of link filtering\n        )\n\n    def fetch_url_contents(self) -> list[dict]:\n        \"\"\"Load documents from the configured URLs.\n\n        Returns:\n            List[Data]: List of Data objects containing the fetched content\n\n        Raises:\n            ValueError: If no valid URLs are provided or if there's an error loading documents\n        \"\"\"\n        try:\n            urls = list({self.ensure_url(url) for url in self.urls if url.strip()})\n            logger.debug(f\"URLs: {urls}\")\n            if not urls:\n                msg = \"No valid URLs provided.\"\n                raise ValueError(msg)\n\n            all_docs = []\n            for url in urls:\n                logger.debug(f\"Loading documents from {url}\")\n\n                try:\n                    loader = self._create_loader(url)\n                    docs = loader.load()\n\n                    if not docs:\n                        logger.warning(f\"No documents found for {url}\")\n                        continue\n\n                    logger.debug(f\"Found {len(docs)} documents from {url}\")\n                    all_docs.extend(docs)\n\n                except requests.exceptions.RequestException as e:\n                    logger.exception(f\"Error loading documents from {url}: {e}\")\n                    continue\n\n            if not all_docs:\n                msg = \"No documents were successfully loaded from any URL\"\n                raise ValueError(msg)\n\n            # data = [Data(text=doc.page_content, **doc.metadata) for doc in all_docs]\n            data = [\n                {\n                    \"text\": safe_convert(doc.page_content, clean_data=True),\n                    \"url\": doc.metadata.get(\"source\", \"\"),\n                    \"title\": doc.metadata.get(\"title\", \"\"),\n                    \"description\": doc.metadata.get(\"description\", \"\"),\n                    \"content_type\": doc.metadata.get(\"content_type\", \"\"),\n                    \"language\": doc.metadata.get(\"language\", \"\"),\n                }\n                for doc in all_docs\n            ]\n        except Exception as e:\n            error_msg = e.message if hasattr(e, \"message\") else e\n            msg = f\"Error loading documents: {error_msg!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n        return data\n\n    def fetch_content(self) -> DataFrame:\n        \"\"\"Convert the documents to a DataFrame.\"\"\"\n        return DataFrame(data=self.fetch_url_contents())\n\n    def fetch_content_as_message(self) -> Message:\n        \"\"\"Convert the documents to a Message.\"\"\"\n        url_contents = self.fetch_url_contents()\n        return Message(text=\"\\n\\n\".join([x[\"text\"] for x in url_contents]), data={\"data\": url_contents})\n"
              },
              "continue_on_failure": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Continue on Failure",
                "dynamic": false,
                "info": "If enabled, continues crawling even if some requests fail.",
                "list": false,
                "list_add_label": "Add More",
                "name": "continue_on_failure",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "filter_text_html": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Filter Text/HTML",
                "dynamic": false,
                "info": "If enabled, filters out text/css content type from the results.",
                "list": false,
                "list_add_label": "Add More",
                "name": "filter_text_html",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "format": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Output Format",
                "dynamic": false,
                "external_options": {},
                "info": "Output Format. Use 'Text' to extract the text from the HTML or 'HTML' for the raw HTML content.",
                "name": "format",
                "options": [
                  "Text",
                  "HTML"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Text"
              },
              "headers": {
                "_input_type": "TableInput",
                "advanced": true,
                "display_name": "Headers",
                "dynamic": false,
                "info": "The headers to send with the request",
                "input_types": [
                  "DataFrame"
                ],
                "is_list": true,
                "list_add_label": "Add More",
                "name": "headers",
                "placeholder": "",
                "required": false,
                "show": true,
                "table_icon": "Table",
                "table_schema": {
                  "columns": [
                    {
                      "default": "None",
                      "description": "Header name",
                      "disable_edit": false,
                      "display_name": "Header",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "key",
                      "sortable": true,
                      "type": "str"
                    },
                    {
                      "default": "None",
                      "description": "Header value",
                      "disable_edit": false,
                      "display_name": "Value",
                      "edit_mode": "popover",
                      "filterable": true,
                      "formatter": "text",
                      "hidden": false,
                      "name": "value",
                      "sortable": true,
                      "type": "str"
                    }
                  ]
                },
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "trigger_icon": "Table",
                "trigger_text": "Open table",
                "type": "table",
                "value": [
                  {
                    "key": "User-Agent",
                    "value": "langflow"
                  }
                ]
              },
              "max_depth": {
                "_input_type": "SliderInput",
                "advanced": false,
                "display_name": "Depth",
                "dynamic": false,
                "info": "Controls how many 'clicks' away from the initial page the crawler will go:\n- depth 1: only the initial page\n- depth 2: initial page + all pages linked directly from it\n- depth 3: initial page + direct links + links found on those direct link pages\nNote: This is about link traversal, not URL path depth.",
                "max_label": " ",
                "max_label_icon": "None",
                "min_label": " ",
                "min_label_icon": "None",
                "name": "max_depth",
                "placeholder": "",
                "range_spec": {
                  "max": 5,
                  "min": 1,
                  "step": 1,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 1
              },
              "prevent_outside": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Prevent Outside",
                "dynamic": false,
                "info": "If enabled, only crawls URLs within the same domain as the root URL. This helps prevent the crawler from going to external websites.",
                "list": false,
                "list_add_label": "Add More",
                "name": "prevent_outside",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "Timeout for the request in seconds.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 30
              },
              "tools_metadata": {
                "_input_type": "ToolsInput",
                "advanced": false,
                "display_name": "Actions",
                "dynamic": false,
                "info": "Modify tool names and descriptions to help agents understand when to use each tool.",
                "is_list": true,
                "list_add_label": "Add More",
                "name": "tools_metadata",
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "tools",
                "value": [
                  {
                    "args": {
                      "urls": {
                        "default": "",
                        "description": "Enter one or more URLs to crawl recursively, by clicking the '+' button.",
                        "items": {
                          "type": "string"
                        },
                        "title": "Urls",
                        "type": "array"
                      }
                    },
                    "description": "Fetch content from one or more web pages, following links recursively.",
                    "display_description": "Fetch content from one or more web pages, following links recursively.",
                    "display_name": "fetch_content",
                    "name": "fetch_content",
                    "readonly": false,
                    "status": true,
                    "tags": [
                      "fetch_content"
                    ]
                  }
                ]
              },
              "urls": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "URLs",
                "dynamic": false,
                "info": "Enter one or more URLs to crawl recursively, by clicking the '+' button.",
                "input_types": [],
                "list": true,
                "list_add_label": "Add URL",
                "load_from_db": false,
                "name": "urls",
                "placeholder": "Enter a URL...",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "use_async": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Use Async",
                "dynamic": false,
                "info": "If enabled, uses asynchronous loading which can be significantly faster but might use more system resources.",
                "list": false,
                "list_add_label": "Add More",
                "name": "use_async",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": true
          },
          "selected_output": "page_results",
          "showNode": true,
          "type": "URLComponent"
        },
        "dragging": false,
        "id": "URLComponent-MKrOi",
        "measured": {
          "height": 289,
          "width": 320
        },
        "position": {
          "x": 1488.7605924091981,
          "y": -50.12682729907255
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Prompt Template-KE2CE",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {
              "template": []
            },
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt Template",
            "documentation": "https://docs.langflow.org/components-prompts",
            "edited": false,
            "error": null,
            "field_order": [
              "template",
              "tool_placeholder"
            ],
            "frozen": false,
            "full_path": null,
            "icon": "braces",
            "is_composition": null,
            "is_input": null,
            "is_output": null,
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "name": "",
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Prompt",
                "group_outputs": false,
                "hidden": null,
                "method": "build_prompt",
                "name": "prompt",
                "options": null,
                "required_inputs": null,
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "priority": 0,
            "replacement": null,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.prompts.api_utils import process_prompt_template\nfrom langflow.custom.custom_component.component import Component\nfrom langflow.inputs.inputs import DefaultPromptField\nfrom langflow.io import MessageTextInput, Output, PromptInput\nfrom langflow.schema.message import Message\nfrom langflow.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt Template\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    documentation: str = \"https://docs.langflow.org/components-prompts\"\n    icon = \"braces\"\n    trace_type = \"prompt\"\n    name = \"Prompt Template\"\n    priority = 0  # Set priority to 0 to make it appear first\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            tool_mode=True,\n            advanced=True,\n            info=\"A placeholder input for tool mode.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(self) -> Message:\n        prompt = Message.from_template(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def _update_template(self, frontend_node: dict):\n        prompt_template = frontend_node[\"template\"][\"template\"][\"value\"]\n        custom_fields = frontend_node[\"custom_fields\"]\n        frontend_node_template = frontend_node[\"template\"]\n        _ = process_prompt_template(\n            template=prompt_template,\n            name=\"template\",\n            custom_fields=custom_fields,\n            frontend_node_template=frontend_node_template,\n        )\n        return frontend_node\n\n    async def update_frontend_node(self, new_frontend_node: dict, current_frontend_node: dict):\n        \"\"\"This function is called after the code validation is done.\"\"\"\n        frontend_node = await super().update_frontend_node(new_frontend_node, current_frontend_node)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        # Kept it duplicated for backwards compatibility\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_frontend_node\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_frontend_node[\"template\"])\n        return frontend_node\n\n    def _get_fallback_input(self, **kwargs):\n        return DefaultPromptField(**kwargs)\n"
              },
              "template": {
                "_input_type": "PromptInput",
                "advanced": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "prompt",
                "value": "Ты - интеллектуальный ассистент службы поддержки компании с архитектурой микросервисов.\n\n## Твоя главная задача:\nПомогать пользователям решать их проблемы быстро и эффективно, строго следуя алгоритму работы, демонстрируя при этом интеллектуальную архитектуру системы.\n\n## ОБЯЗАТЕЛЬНЫЙ АЛГОРИТМ РАБОТЫ (выполняй СТРОГО по порядку):\n\n### ШАГ 0: ДЕМОНСТРАЦИЯ АРХИТЕКТУРЫ (для первого запроса в сессии)\n\n🎯 **Когда использовать:** Если это первое сообщение пользователя ИЛИ пользователь задал новый вопрос (не продолжение диалога)\n\n**Признаки НОВОГО вопроса (используй ШАГ 0):**\n- Первое сообщение в беседе\n- Вопрос содержит полный контекст (существительные, глаголы)\n- Смена темы разговора\n- Длинное сообщение (> 10 слов)\n- Примеры: \"нужно внести правки в график\", \"сбросить пароль\", \"как оформить отпуск\"\n\n**Признаки УТОЧНЕНИЯ (НЕ используй ШАГ 0):**\n- Короткий вопрос (< 10 слов)\n- Содержит слова: \"а\", \"еще\", \"также\", \"сколько\", \"когда\", \"где\", \"почему\"\n- Отсутствие четкого контекста\n- Ссылка на предыдущий ответ (\"это\", \"такое\", \"то\")\n- Примеры: \"а сколько времени?\", \"а где это сделать?\", \"еще вопрос\"\n\n**Действия для НОВОГО вопроса:**\n\n1. **СНАЧАЛА** вызови `smart_orchestration_router` с полным текстом запроса пользователя\n   - Это покажет интеллектуальную маршрутизацию к специализированному обработчику\n   - Демонстрирует микросервисную архитектуру системы\n   - Показывает, какой handler (HR, IT, Finance) будет обрабатывать запрос\n   \n2. **ЗАТЕМ** вызови `show_processing_monitor` с типом операции\n   - Это покажет real-time мониторинг всех микросервисов\n   - Демонстрирует observability и состояние системы\n   - Типы операций:\n     * \"Query Processing\" - для общих запросов\n     * \"HR Query Processing\" - для HR-вопросов\n     * \"IT Support Request\" - для IT-запросов\n     * \"System Action Request\" - для действий в системе\n     * \"Technical Query\" - для технических вопросов\n\n⚠️ **КРИТИЧЕСКИ ВАЖНО**: \n- Эти два инструмента используй ТОЛЬКО для демонстрации архитектуры!\n- Они НЕ влияют на основную логику обработки запроса!\n- Они НЕ заменяют другие инструменты!\n- После демонстрации ОБЯЗАТЕЛЬНО продолжай основной алгоритм (ШАГ 1)!\n\n**Для УТОЧНЕНИЙ:** Пропусти ШАГ 0 и сразу переходи к ШАГу 1.\n\n---\n\n### ШАГ 1: КЛАССИФИКАЦИЯ (ОБЯЗАТЕЛЬНЫЙ первый шаг для КАЖДОГО запроса)\n⚠️ ВСЕГДА начинай с вызова `classify_request` - это КРИТИЧЕСКИ ВАЖНО!\n\nПосле классификации ты получишь одну из категорий:\n- **HR_PROCESS** - вопросы о HR-процедурах (отпуска, больничные, графики работы)\n- **EMPLOYEE_INFO** - запросы информации о себе/сотруднике\n- **REQUEST_CREATE** - создание новой заявки\n- **REQUEST_STATUS** - проверка статуса заявки\n- **SYSTEM_ACTION** - выполнение действий в системе (сброс пароля, создание учетки)\n- **TECHNICAL** - технические вопросы (как решить проблему)\n- **POLICY** - вопросы о правилах и политиках компании\n- **EXTERNAL_SEARCH** - поиск информации в интернете\n- **GENERAL** - общие вопросы\n\n### ШАГ 2: ВЫБОР ИНСТРУМЕНТА (строго по категории из классификации)\n\n📋 **Категория HR_PROCESS** → Инструмент: `search_knowledge_base`\n   Примеры вопросов:\n   - \"как изменить график работы сотруднику\"\n   - \"процедура оформления отпуска\"\n   - \"правила больничного\"\n   - \"внести правки в расписание\"\n   🔧 Действие: ОБЯЗАТЕЛЬНО вызови search_knowledge_base с запросом пользователя\n\n📋 **Категория EMPLOYEE_INFO** → Инструмент: `get_employee_info`\n   Примеры вопросов:\n   - \"покажи мою информацию\"\n   - \"сколько у меня осталось дней отпуска\"\n   - \"мой график работы\"\n   🔧 Действие: Вызови get_employee_info с описанием запроса\n\n📋 **Категория REQUEST_CREATE** → Инструмент: `create_request`\n   Примеры вопросов:\n   - \"создать заявку на отпуск\"\n   - \"хочу взять больничный\"\n   - \"нужно оформить командировку\"\n   🔧 Действие: Собери необходимые данные, затем вызови create_request\n\n📋 **Категория REQUEST_STATUS** → Инструмент: `check_request_status`\n   Примеры вопросов:\n   - \"статус моей заявки\"\n   - \"где моя заявка REQ-123\"\n   🔧 Действие: Вызови check_request_status с номером заявки\n\n📋 **Категория SYSTEM_ACTION** → Инструмент: `execute_system_action`\n   ⚠️ КРИТИЧЕСКИ ВАЖНО: Это действия, которые агент выполняет В системе ЗА пользователя!\n   \n   Примеры запросов (ДЕЙСТВИЯ):\n   - \"сбросить пароль\" / \"сброс пароля\"\n   - \"создать учетную запись\" / \"получить учетку\"\n   - \"разблокировать аккаунт\"\n   - \"выдать доступ к системе\"\n   - \"активировать пользователя\"\n   - \"сбросить двухфакторную аутентификацию\"\n   \n   🔧 Действие:\n   1. ОБЯЗАТЕЛЬНО спроси подтверждение у пользователя\n   2. Объясни ЧТО ИМЕННО будет сделано\n   3. Только после подтверждения → вызови execute_system_action\n   \n   ❌ НЕ ПУТАЙ с вопросами \"КАК сбросить пароль\" (это TECHNICAL → search_knowledge_base)\n   \n   Различие:\n   - \"сбросить пароль\" = SYSTEM_ACTION (пользователь просит СДЕЛАТЬ)\n   - \"как сбросить пароль\" = TECHNICAL (пользователь просит ОБЪЯСНИТЬ)\n\n📋 **Категория TECHNICAL** → Инструмент: `search_knowledge_base`\n   Примеры вопросов (ВОПРОСЫ, а не действия):\n   - \"как сбросить пароль\"\n   - \"не могу войти в систему, что делать\"\n   - \"проблема с доступом\"\n   - \"как получить учетную запись\"\n   🔧 Действие: ОБЯЗАТЕЛЬНО вызови search_knowledge_base для поиска инструкции\n\n📋 **Категория POLICY** → Инструмент: `search_knowledge_base`\n   Примеры вопросов:\n   - \"правила использования корпоративной почты\"\n   - \"политика безопасности\"\n   🔧 Действие: ОБЯЗАТЕЛЬНО вызови search_knowledge_base\n\n📋 **Категория EXTERNAL_SEARCH** → Инструмент: `url_search`\n   Примеры вопросов:\n   - \"найди в интернете информацию о НДФЛ\"\n   - \"что пишут про...\"\n   🔧 Действие: Вызови url_search\n\n📋 **Категория GENERAL** → Проверка на ключевые слова\n   ⚠️ ВНИМАНИЕ! Даже если категория GENERAL, проверь вопрос на наличие:\n   - Слова: график, заявка, процедура, правила, отпуск, больничный, система\n   - Если ЛЮБОЕ из этих слов есть → ОБЯЗАТЕЛЬНО вызови `search_knowledge_base`\n   - Если ключевых слов нет → ответь из своих знаний\n\n### ШАГ 3: ОЦЕНКА РЕЗУЛЬТАТА (после получения ответа от инструмента)\n\nЕсли использовал `search_knowledge_base`:\n- **Релевантность ≥ 0.7**: Дай ответ на основе найденной информации\n- **Релевантность 0.6-0.7**: Дай ответ + предложи связаться с оператором\n- **Релевантность < 0.6**: ОБЯЗАТЕЛЬНО вызови `escalate_to_human`\n\nЕсли использовал `execute_system_action`:\n- Проверь результат выполнения\n- Сообщи пользователю о результате\n- Если ошибка → вызови `escalate_to_human`\n\nЕсли использовал другие инструменты:\n- Оцени, достаточно ли информации для ответа\n- Если недостаточно → вызови `escalate_to_human`\n\n### ШАГ 4: ПРОВЕРКА БЕЗОПАСНОСТИ (перед финальным ответом)\n- Используй `check_toxicity` для проверки своего ответа\n- Если обнаружена токсичность → переформулируй\n\n### ШАГ 5: ФИНАЛЬНЫЙ ОТВЕТ\n- Дай четкий, структурированный ответ пользователю\n- Не упоминай технические детали работы инструментов\n- Сформулируй ответ естественным языком\n\n## ⚠️ КРИТИЧЕСКИЕ ПРАВИЛА:\n\n1. **ШАГ 0 - только для демонстрации**: Используй `smart_orchestration_router` и `show_processing_monitor` ТОЛЬКО для первого запроса или новых вопросов, НЕ для уточнений\n2. **НИКОГДА не пропускай классификацию!** Каждый запрос НАЧИНАЕТСЯ с `classify_request`\n3. **СТРОГО следуй маппингу категория → инструмент** из ШАГа 2\n4. **РАЗЛИЧАЙ запросы на действие vs вопросы:**\n   - \"сбросить пароль\" → SYSTEM_ACTION → execute_system_action\n   - \"как сбросить пароль\" → TECHNICAL → search_knowledge_base\n5. **ВСЕГДА спрашивай подтверждение** перед execute_system_action\n6. **НЕ отвечай на корпоративные вопросы без поиска** в базе знаний\n7. **ВСЕГДА проверяй GENERAL-категорию** на ключевые слова\n8. **Используй эскалацию** при низкой уверенности (< 60%)\n\n## Доступные инструменты:\n\n### Основные инструменты (используй по алгоритму):\n- `classify_request` - классификация обращения (ВСЕГДА первый шаг!)\n- `search_knowledge_base` - поиск в корпоративной базе знаний\n- `get_employee_info` - информация о сотруднике\n- `create_request` - создание заявки\n- `check_request_status` - статус заявки\n- `execute_system_action` - выполнение действий в системе (сброс пароля, создание учеток)\n- `escalate_to_human` - передача оператору\n- `check_toxicity` - проверка безопасности\n- `url_search` - поиск в интернете\n\n### Демонстрационные инструменты (для показа архитектуры):\n- `smart_orchestration_router` - интеллектуальная маршрутизация к специализированным обработчикам\n- `show_processing_monitor` - real-time мониторинг статуса микросервисов\n\n## Примеры правильной работы:\n\n**Пример 1: Первый запрос пользователя (с демонстрацией архитектуры)**\nПользователь: \"нужно внести правки в график моему сотруднику\"\n\n1. ✅ **ШАГ 0.1**: Вызов `smart_orchestration_router(\"нужно внести правки в график моему сотруднику\")`\n   → Показывает: Назначен HR Specialist Handler 👔, цепочка обработки\n   \n2. ✅ **ШАГ 0.2**: Вызов `show_processing_monitor(\"HR Query Processing\")`\n   → Показывает: Статус микросервисов, метрики системы\n\n3. ✅ **ШАГ 1**: Вызов `classify_request(\"нужно внести правки в график моему сотруднику\")`\n   → Получил HR_PROCESS\n   \n4. ✅ **ШАГ 2**: По маппингу HR_PROCESS → search_knowledge_base\n   \n5. ✅ Вызов `search_knowledge_base(\"внесение правок в график сотруднику\")`\n   → Получил результаты с релевантностью 0.85\n   \n6. ✅ **ШАГ 4**: Проверка `check_toxicity(твой_ответ)`\n   \n7. ✅ **ШАГ 5**: Ответ пользователю на основе найденной информации\n\n**Пример 2: Уточняющий вопрос (БЕЗ демонстрации архитектуры)**\nПользователь: \"а сколько это займет времени?\"\n\n1. ❌ **ШАГ 0**: ПРОПУСКАЕМ (это уточнение, не новый вопрос)\n\n2. ✅ **ШАГ 1**: Вызов `classify_request(\"а сколько это займет времени?\")`\n   → Получил HR_PROCESS\n   \n3. ✅ **ШАГ 2**: Вызов `search_knowledge_base(\"время обработки изменения графика\")`\n   \n4. ✅ **ШАГ 5**: Ответ пользователю\n\n**Пример 3: Запрос на действие**\nПользователь: \"сбросить пароль\"\n\n1. ✅ **ШАГ 0.1**: Вызов `smart_orchestration_router(\"сбросить пароль\")`\n   → Назначен IT Support Handler ⚙️\n   \n2. ✅ **ШАГ 0.2**: Вызов `show_processing_monitor(\"System Action Request\")`\n   \n3. ✅ **ШАГ 1**: Вызов `classify_request(\"сбросить пароль\")`\n   → Получил SYSTEM_ACTION\n   \n4. ✅ **ШАГ 2**: По маппингу SYSTEM_ACTION → execute_system_action\n   \n5. ✅ Запрос подтверждения: \"Вы хотите сбросить пароль для вашей учетной записи? Новый временный пароль будет отправлен на email. Подтверждаете?\"\n   \n6. ✅ После подтверждения → вызов `execute_system_action(\"reset_password\")`\n   \n7. ✅ Сообщение о результате пользователю\n\n**Пример 4: Вопрос КАК сделать**\nПользователь: \"как сбросить пароль\"\n\n1. ✅ **ШАГ 0.1**: Вызов `smart_orchestration_router(\"как сбросить пароль\")`\n   → Назначен IT Support Handler ⚙️\n   \n2. ✅ **ШАГ 0.2**: Вызов `show_processing_monitor(\"Technical Query\")`\n   \n3. ✅ **ШАГ 1**: Вызов `classify_request(\"как сбросить пароль\")`\n   → Получил TECHNICAL\n   \n4. ✅ **ШАГ 2**: По маппингу TECHNICAL → search_knowledge_base\n   \n5. ✅ Вызов `search_knowledge_base(\"как сбросить пароль\")`\n   → Получил инструкцию\n   \n6. ✅ **ШАГ 5**: Ответ с пошаговой инструкцией\n\n## 💡 КЛЮЧЕВЫЕ МОМЕНТЫ:\n\n- Инструменты `smart_orchestration_router` и `show_processing_monitor` - это **визуальная демонстрация** архитектуры системы\n- Они НЕ влияют на основную логику работы и НЕ заменяют другие инструменты\n- Используй их ТОЛЬКО в начале обработки НОВОГО вопроса (не для уточнений)\n- Основной алгоритм (классификация → поиск → ответ) остается неизменным\n- Вся существующая логика работы с `search_knowledge_base` сохраняется полностью"
              },
              "tool_placeholder": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Tool Placeholder",
                "dynamic": false,
                "info": "A placeholder input for tool mode.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "tool_placeholder",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Prompt Template"
        },
        "dragging": false,
        "id": "Prompt Template-KE2CE",
        "measured": {
          "height": 283,
          "width": 320
        },
        "position": {
          "x": 2064.1593718100685,
          "y": 1263.4137000904336
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatInput-rPhQw",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get chat inputs from the Playground.",
            "display_name": "Chat Input",
            "documentation": "https://docs.langflow.org/components-io#chat-input",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Chat Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-input\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Input Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n            temp_file=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Chat Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        # Ensure files is a list and filter out empty/None values\n        files = self.files if self.files else []\n        if files and not isinstance(files, list):\n            files = [files]\n        files = [f for f in files if f is not None and f != \"\"]\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=files,\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n"
              },
              "files": {
                "_input_type": "FileInput",
                "advanced": true,
                "display_name": "Files",
                "dynamic": false,
                "fileTypes": [
                  "csv",
                  "json",
                  "pdf",
                  "txt",
                  "md",
                  "mdx",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "file_path": "",
                "info": "Files to be sent with the message.",
                "list": true,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": false,
                "show": true,
                "temp_file": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Input Text",
                "dynamic": false,
                "info": "Message to be passed as input.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "external_options": {},
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ChatInput"
        },
        "dragging": false,
        "id": "ChatInput-rPhQw",
        "measured": {
          "height": 203,
          "width": 320
        },
        "position": {
          "x": 1496.384200429445,
          "y": 1004.6403406373022
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-oaZFI",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "https://docs.langflow.org/components-io#chat-output",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Output Message",
                "group_outputs": false,
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.helpers.data import safe_convert\nfrom langflow.inputs.inputs import BoolInput, DropdownInput, HandleInput, MessageTextInput\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.template.field.base import Output\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    documentation: str = \"https://docs.langflow.org/components-io#chat-output\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Inputs\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Output Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, _icon, display_name, source_id = self.get_properties_from_source_component()\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            clean_data: bool = getattr(self, \"clean_data\", False)\n            return \"\\n\".join([safe_convert(item, clean_data=clean_data) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Inputs",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "external_options": {},
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ChatOutput"
        },
        "dragging": false,
        "id": "ChatOutput-oaZFI",
        "measured": {
          "height": 165,
          "width": 320
        },
        "position": {
          "x": 4558.644399474311,
          "y": 217.254722920774
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CustomComponent-487Wh",
          "node": {
            "base_classes": [
              "Tool"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Проверяет текст на токсичность перед отправкой",
            "display_name": "Toxicity Check Tool",
            "documentation": "",
            "edited": true,
            "field_order": [],
            "frozen": false,
            "icon": "shield-check",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Tool",
                "group_outputs": false,
                "hidden": null,
                "method": "build_tool",
                "name": "tool_output",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\r\nfrom langflow.io import Output, StrInput\r\nfrom langflow.schema.message import Message\r\nfrom langchain.tools import Tool\r\nfrom typing import Optional\r\nimport json\r\nfrom datetime import datetime\r\n\r\nclass ToxicityCheckTool(Component):\r\n    display_name = \"Toxicity Check Tool\"\r\n    description = \"Проверяет текст на токсичность перед отправкой\"\r\n    icon = \"shield-check\"\r\n    name = \"ToxicityCheck\"\r\n    \r\n    outputs = [\r\n        Output(display_name=\"Tool\", name=\"tool_output\", method=\"build_tool\"),\r\n    ]\r\n\r\n    def check_toxicity(self, text: str) -> str:\r\n        \"\"\"\r\n        Проверка токсичности текста\r\n        \"\"\"\r\n        toxic_words = [\"идиот\", \"дурак\", \"тупой\", \"stupid\", \"idiot\", \"hate\"]\r\n        text_lower = text.lower()\r\n        \r\n        toxicity_score = sum(1 for word in toxic_words if word in text_lower) * 0.3\r\n        toxicity_score = min(1.0, toxicity_score)\r\n        \r\n        is_safe = toxicity_score < 0.3\r\n        \r\n        result = f\"\"\"\r\n🛡️ ПРОВЕРКА БЕЗОПАСНОСТИ КОНТЕНТА\r\n\r\nТекст: \"{text[:100]}{'...' if len(text) > 100 else ''}\"\r\nОценка токсичности: {toxicity_score:.2f}/1.00\r\nСтатус: {\"✅ БЕЗОПАСНО\" if is_safe else \"⚠️ ОБНАРУЖЕНА ТОКСИЧНОСТЬ\"}\r\n\r\n{\"Текст можно отправить пользователю.\" if is_safe else \"Рекомендуется переформулировать текст перед отправкой.\"}\r\n\"\"\"\r\n        \r\n        self.log(f\"Toxicity check: score={toxicity_score}, safe={is_safe}\")\r\n        return result\r\n    \r\n    def build_tool(self) -> Tool:\r\n        \"\"\"\r\n        Создает Tool для Agent\r\n        \"\"\"\r\n        return Tool(\r\n            name=\"check_toxicity\",\r\n            description=(\r\n                \"Проверяет текст на наличие токсичного, оскорбительного или неподобающего контента \"\r\n                \"перед отправкой пользователю. Используй этот инструмент для валидации ответов. \"\r\n                \"Входной параметр: text - текст для проверки (строка)\"\r\n            ),\r\n            func=self.check_toxicity,\r\n        )"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ToxicityCheck"
        },
        "dragging": false,
        "id": "CustomComponent-487Wh",
        "measured": {
          "height": 137,
          "width": 320
        },
        "position": {
          "x": 2023.4742147017168,
          "y": -162.82605358698413
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CustomComponent-wIqXI",
          "node": {
            "base_classes": [
              "Tool"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Проверяет статус заявки в системе",
            "display_name": "Check Request Status Tool",
            "documentation": "",
            "edited": true,
            "field_order": [],
            "frozen": false,
            "icon": "clipboard-check",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Tool",
                "group_outputs": false,
                "hidden": null,
                "method": "build_tool",
                "name": "tool_output",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\r\nfrom langflow.io import Output\r\nfrom langflow.schema.message import Message\r\nfrom langchain.tools import Tool\r\nfrom datetime import datetime, timedelta\r\nimport random\r\nimport hashlib\r\n\r\n\r\nclass CheckRequestStatusTool(Component):\r\n    display_name = \"Check Request Status Tool\"\r\n    description = \"Проверяет статус заявки в системе\"\r\n    icon = \"clipboard-check\"\r\n    name = \"CheckRequestStatus\"\r\n    \r\n    outputs = [\r\n        Output(display_name=\"Tool\", name=\"tool_output\", method=\"build_tool\"),\r\n    ]\r\n\r\n    def check_status(self, request_id: str) -> str:\r\n        \"\"\"\r\n        Проверка статуса заявки\r\n        \"\"\"\r\n        # Симуляция разных типов заявок\r\n        request_types = {\r\n            \"VACATION\": \"Заявка на отпуск\",\r\n            \"SICK_LEAVE\": \"Регистрация больничного\",\r\n            \"TRANSFER\": \"Запрос на перевод\",\r\n            \"DOCUMENT\": \"Заказ справки 2-НДФЛ\",\r\n            \"DATA_CHANGE\": \"Изменение личных данных\",\r\n        }\r\n        \r\n        statuses = [\r\n            (\"Создана\", \"🟡\", 100),\r\n            (\"На рассмотрении у руководителя\", \"🟡\", 80),\r\n            (\"Одобрена руководителем\", \"🟢\", 60),\r\n            (\"На обработке в HR\", \"🟡\", 40),\r\n            (\"Завершена\", \"🟢\", 0),\r\n        ]\r\n        \r\n        # Генерируем \"реалистичные\" данные на основе ID\r\n        request_type_key = list(request_types.keys())[hash(request_id) % len(request_types)]\r\n        request_type = request_types[request_type_key]\r\n        \r\n        current_status_idx = hash(request_id) % len(statuses)\r\n        status_name, status_icon, days_left = statuses[current_status_idx]\r\n        \r\n        # Генерируем даты\r\n        created_date = (datetime.now() - timedelta(days=random.randint(1, 10))).strftime(\"%d.%m.%Y\")\r\n        expected_date = (datetime.now() + timedelta(days=days_left if days_left > 0 else 0)).strftime(\"%d.%m.%Y\")\r\n        \r\n        # Прогресс-бар\r\n        progress = ((len(statuses) - current_status_idx) / len(statuses)) * 100\r\n        progress_bar = \"█\" * int(progress / 10) + \"░\" * (10 - int(progress / 10))\r\n        \r\n        # Формируем красивый ответ\r\n        result = f\"\"\"\r\n╔═══════════════════════════════════════════════════════╗\r\n║           СТАТУС ЗАЯВКИ #{request_id}                 ║\r\n╚═══════════════════════════════════════════════════════╝\r\n\r\n📋 Тип заявки: {request_type}\r\n📅 Дата создания: {created_date}\r\n{status_icon} Текущий статус: {status_name}\r\n\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\nПРОГРЕСС ОБРАБОТКИ:\r\n{progress_bar} {int(progress)}%\r\n\r\nЭТАПЫ:\r\n{\"✅\" if current_status_idx >= 4 else \"⏳\"} 1. Создание заявки\r\n{\"✅\" if current_status_idx >= 3 else \"⏳\" if current_status_idx == 4 else \"⬜\"} 2. Рассмотрение руководителем\r\n{\"✅\" if current_status_idx >= 2 else \"⏳\" if current_status_idx == 3 else \"⬜\"} 3. Одобрение\r\n{\"✅\" if current_status_idx >= 1 else \"⏳\" if current_status_idx == 2 else \"⬜\"} 4. Обработка в HR\r\n{\"✅\" if current_status_idx >= 0 else \"⏳\" if current_status_idx == 1 else \"⬜\"} 5. Завершение\r\n\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n{\"⏰ Ожидаемая дата завершения: \" + expected_date if days_left > 0 else \"✅ Заявка завершена!\"}\r\n\r\n{\"💡 Совет: Заявка обрабатывается в обычном режиме. Вы получите уведомление при изменении статуса.\" if days_left > 0 else \"✅ Все готово! Результаты направлены на вашу почту.\"}\r\n\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n📞 Вопросы? Обратитесь в HR: +7 (495) 123-45-67\r\n\"\"\"\r\n        \r\n        self.log(f\"Status check for request #{request_id}: {status_name}\")\r\n        return result\r\n    \r\n    def build_tool(self) -> Tool:\r\n        \"\"\"\r\n        Создает Tool для Agent\r\n        \"\"\"\r\n        return Tool(\r\n            name=\"check_request_status\",\r\n            description=(\r\n                \"Проверяет статус заявки в корпоративной системе. \"\r\n                \"Показывает текущий этап обработки, прогресс и ожидаемую дату завершения. \"\r\n                \"Работает для всех типов заявок: отпуска, больничные, переводы, справки, изменение данных. \"\r\n                \"Входной параметр: request_id - номер заявки (строка, например '12345' или 'REQ-2024-001')\"\r\n            ),\r\n            func=self.check_status,\r\n        )"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "CheckRequestStatus"
        },
        "dragging": false,
        "id": "CustomComponent-wIqXI",
        "measured": {
          "height": 121,
          "width": 320
        },
        "position": {
          "x": 2397.369529726272,
          "y": -211.8249690395703
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CustomComponent-q1rbD",
          "node": {
            "base_classes": [
              "Tool"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Получает информацию о сотруднике из HR системы",
            "display_name": "Employee Info Tool",
            "documentation": "",
            "edited": true,
            "field_order": [],
            "frozen": false,
            "icon": "user",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Tool",
                "group_outputs": false,
                "hidden": null,
                "method": "build_tool",
                "name": "tool_output",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\r\nfrom langflow.io import Output\r\nfrom langflow.schema.message import Message\r\nfrom langchain.tools import Tool\r\nfrom datetime import datetime, timedelta\r\nimport random\r\n\r\n\r\nclass EmployeeInfoTool(Component):\r\n    display_name = \"Employee Info Tool\"\r\n    description = \"Получает информацию о сотруднике из HR системы\"\r\n    icon = \"user\"\r\n    name = \"EmployeeInfo\"\r\n    \r\n    outputs = [\r\n        Output(display_name=\"Tool\", name=\"tool_output\", method=\"build_tool\"),\r\n    ]\r\n\r\n    def get_employee_info(self, query: str) -> str:\r\n        \"\"\"\r\n        Получение информации о сотруднике\r\n        \"\"\"\r\n        # Генерируем \"реалистичные\" данные\r\n        departments = [\"IT отдел\", \"HR отдел\", \"Бухгалтерия\", \"Маркетинг\", \"Продажи\"]\r\n        positions = [\"Специалист\", \"Старший специалист\", \"Ведущий специалист\", \"Менеджер\"]\r\n        managers = [\r\n            \"Иванов Иван Иванович\",\r\n            \"Петрова Мария Сергеевна\",\r\n            \"Сидоров Алексей Викторович\"\r\n        ]\r\n        \r\n        # Генерируем данные на основе запроса\r\n        dept = departments[hash(query) % len(departments)]\r\n        position = positions[hash(query) % len(positions)]\r\n        manager = managers[hash(query) % len(managers)]\r\n        \r\n        # Генерируем даты\r\n        hire_date = (datetime.now() - timedelta(days=random.randint(365, 2000))).strftime(\"%d.%m.%Y\")\r\n        vacation_days_left = random.randint(5, 28)\r\n        sick_days_used = random.randint(0, 10)\r\n        \r\n        # Рабочий график\r\n        schedules = [\"5/2 (9:00-18:00)\", \"Гибкий график\", \"Удаленная работа\", \"4/3 (10:00-19:00)\"]\r\n        schedule = schedules[hash(query) % len(schedules)]\r\n        \r\n        # Статус\r\n        statuses = {\r\n            \"active\": (\"🟢 Работает\", \"Активен\"),\r\n            \"vacation\": (\"🟡 В отпуске\", \"До 15.11.2024\"),\r\n            \"sick\": (\"🔴 На больничном\", \"До 25.10.2024\"),\r\n        }\r\n        status_key = list(statuses.keys())[hash(query) % len(statuses)]\r\n        status_icon, status_text = statuses[status_key]\r\n        \r\n        result = f\"\"\"\r\n╔═══════════════════════════════════════════════════════╗\r\n║              👤 КАРТОЧКА СОТРУДНИКА                   ║\r\n╚═══════════════════════════════════════════════════════╝\r\n\r\n{status_icon} Статус: {status_text}\r\n\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n📋 ОСНОВНАЯ ИНФОРМАЦИЯ:\r\n\r\nДолжность: {position}\r\nОтдел: {dept}\r\nНепосредственный руководитель: {manager}\r\nДата приема на работу: {hire_date}\r\nТип занятости: Полная ставка (100%)\r\n\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n⏰ ГРАФИК РАБОТЫ:\r\n\r\nРежим: {schedule}\r\nОфис: Москва, БЦ \"Центральный\", 3 этаж\r\n\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n🏖️ ОТПУСКА И БОЛЬНИЧНЫЕ:\r\n\r\nОстаток отпускных дней: {vacation_days_left} дней\r\nИспользовано больничных в этом году: {sick_days_used} дней\r\nСледующий запланированный отпуск: {\"Нет\" if vacation_days_left > 20 else \"15-29 декабря 2024\"}\r\n\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n💰 ВЫПЛАТЫ:\r\n\r\nГрафик выплат:\r\n  • Аванс: 15 числа каждого месяца\r\n  • Зарплата: 30 числа каждого месяца\r\n\r\nБлижайшая выплата: {(datetime.now() + timedelta(days=random.randint(1, 15))).strftime(\"%d.%m.%Y\")}\r\n\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n📞 КОНТАКТЫ:\r\n\r\nEmail: {query.lower().replace(' ', '.')}@company.com\r\nВнутренний телефон: {random.randint(1000, 9999)}\r\nЛичный кабинет: https://hr.company.com\r\n\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n💡 Что я могу сделать:\r\n  • Создать заявку на отпуск\r\n  • Заказать справку 2-НДФЛ\r\n  • Изменить личные данные\r\n  • Проверить статус заявки\r\n\"\"\"\r\n        \r\n        self.log(f\"Employee info retrieved for: {query}\")\r\n        return result\r\n    \r\n    def build_tool(self) -> Tool:\r\n        \"\"\"\r\n        Создает Tool для Agent\r\n        \"\"\"\r\n        return Tool(\r\n            name=\"get_employee_info\",\r\n            description=(\r\n                \"Получает подробную информацию о сотруднике из HR системы. \"\r\n                \"Показывает статус, должность, отдел, руководителя, график работы, \"\r\n                \"остаток отпускных дней, информацию о выплатах и контакты. \"\r\n                \"Используй когда пользователь спрашивает о себе, своем статусе, отпусках, графике работы. \"\r\n                \"Входной параметр: query - что именно хочет узнать пользователь (строка, например 'моя информация' или 'сколько дней отпуска')\"\r\n            ),\r\n            func=self.get_employee_info,\r\n        )"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "EmployeeInfo"
        },
        "dragging": false,
        "id": "CustomComponent-q1rbD",
        "measured": {
          "height": 137,
          "width": 320
        },
        "position": {
          "x": 2818.406623676353,
          "y": -376.52377004816105
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CustomComponent-qRuGK",
          "node": {
            "base_classes": [
              "Tool"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Интеллектуальная маршрутизация запросов к специализированным обработчикам",
            "display_name": "Smart Orchestration Router",
            "documentation": "",
            "edited": true,
            "field_order": [],
            "frozen": false,
            "icon": "route",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Tool",
                "group_outputs": false,
                "hidden": null,
                "method": "build_tool",
                "name": "tool_output",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\r\nfrom langflow.io import Output\r\nfrom langflow.schema.message import Message\r\nfrom langchain.tools import Tool\r\nfrom typing import Dict, List\r\nimport json\r\nfrom datetime import datetime\r\n\r\n\r\nclass SmartOrchestrationRouter(Component):\r\n    display_name = \"Smart Orchestration Router\"\r\n    description = \"Интеллектуальная маршрутизация запросов к специализированным обработчикам\"\r\n    icon = \"route\"\r\n    name = \"SmartOrchestrationRouter\"\r\n    \r\n    outputs = [\r\n        Output(display_name=\"Tool\", name=\"tool_output\", method=\"build_tool\"),\r\n    ]\r\n    \r\n    def get_handler_emoji(self, handler_type: str) -> str:\r\n        \"\"\"Возвращает эмодзи для типа обработчика\"\"\"\r\n        emojis = {\r\n            \"HR Specialist\": \"👔\",\r\n            \"IT Support\": \"⚙️\",\r\n            \"Finance\": \"💰\",\r\n            \"General Assistant\": \"🤖\",\r\n            \"System Admin\": \"🔧\",\r\n            \"Knowledge Expert\": \"📚\"\r\n        }\r\n        return emojis.get(handler_type, \"🎯\")\r\n    \r\n    def route_request(self, user_query: str) -> str:\r\n        \"\"\"\r\n        Анализирует запрос и маршрутизирует к специализированному обработчику\r\n        \"\"\"\r\n        query_lower = user_query.lower()\r\n        \r\n        # Определяем специализацию обработчика на основе контента\r\n        routing_rules = {\r\n            \"HR Specialist\": {\r\n                \"keywords\": [\"график\", \"отпуск\", \"больничный\", \"расписание\", \"смена\", \"hr\", \"сотрудник\", \"правки в график\"],\r\n                \"confidence_boost\": 0.2,\r\n                \"services\": [\"Employee Database\", \"Schedule Manager\", \"Leave Management\"]\r\n            },\r\n            \"IT Support\": {\r\n                \"keywords\": [\"пароль\", \"доступ\", \"система\", \"логин\", \"учетная запись\", \"it\", \"техническая\", \"сбросить\"],\r\n                \"confidence_boost\": 0.2,\r\n                \"services\": [\"Identity Management\", \"Access Control\", \"System Monitor\"]\r\n            },\r\n            \"Finance\": {\r\n                \"keywords\": [\"зарплата\", \"выплата\", \"аванс\", \"ндфл\", \"справка\", \"2-ндфл\", \"налог\"],\r\n                \"confidence_boost\": 0.2,\r\n                \"services\": [\"Payroll System\", \"Tax Calculator\", \"Document Generator\"]\r\n            },\r\n            \"System Admin\": {\r\n                \"keywords\": [\"создать\", \"удалить\", \"активировать\", \"разблокировать\", \"настроить\", \"выдать\"],\r\n                \"confidence_boost\": 0.15,\r\n                \"services\": [\"User Provisioning\", \"Permission Manager\", \"Audit Logger\"]\r\n            },\r\n            \"Knowledge Expert\": {\r\n                \"keywords\": [\"как\", \"правила\", \"политика\", \"процедура\", \"инструкция\", \"регламент\"],\r\n                \"confidence_boost\": 0.15,\r\n                \"services\": [\"Knowledge Base\", \"Policy Engine\", \"Training Materials\"]\r\n            }\r\n        }\r\n        \r\n        # Подсчитываем совпадения для каждого типа обработчика\r\n        handler_scores = {}\r\n        for handler_type, config in routing_rules.items():\r\n            matches = sum(1 for keyword in config[\"keywords\"] if keyword in query_lower)\r\n            base_score = min(0.95, 0.5 + (matches * 0.15))\r\n            handler_scores[handler_type] = {\r\n                \"score\": base_score + (config[\"confidence_boost\"] if matches > 0 else 0),\r\n                \"matches\": matches,\r\n                \"services\": config[\"services\"]\r\n            }\r\n        \r\n        # Выбираем лучший обработчик\r\n        if all(score[\"matches\"] == 0 for score in handler_scores.values()):\r\n            selected_handler = \"General Assistant\"\r\n            confidence = 0.6\r\n            services = [\"Chat Engine\", \"NLP Processor\", \"Context Manager\"]\r\n        else:\r\n            selected_handler = max(handler_scores.items(), key=lambda x: x[1][\"score\"])[0]\r\n            confidence = handler_scores[selected_handler][\"score\"]\r\n            services = handler_scores[selected_handler][\"services\"]\r\n        \r\n        # Генерируем ID маршрутизации\r\n        route_id = f\"ROUTE-{datetime.now().strftime('%Y%m%d-%H%M%S')}\"\r\n        \r\n        # Формируем красивый ответ\r\n        emoji = self.get_handler_emoji(selected_handler)\r\n        \r\n        result = f\"\"\"\r\n╔══════════════════════════════════════════════════════════╗\r\n║          🎯 ИНТЕЛЛЕКТУАЛЬНАЯ МАРШРУТИЗАЦИЯ              ║\r\n╚══════════════════════════════════════════════════════════╝\r\n\r\n📋 Запрос: \"{user_query[:60]}{'...' if len(user_query) > 60 else ''}\"\r\n🆔 Route ID: {route_id}\r\n\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n🎯 НАЗНАЧЕННЫЙ ОБРАБОТЧИК:\r\n{emoji} {selected_handler} Handler\r\n📊 Уверенность: {confidence:.0%}\r\n\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n🔗 ЦЕПОЧКА ОБРАБОТКИ:\r\n\"\"\"\r\n        \r\n        # Добавляем микросервисы в цепочку\r\n        for i, service in enumerate(services, 1):\r\n            status_icon = \"⚡\" if i == 1 else \"⏳\"\r\n            result += f\"\\n{status_icon} {i}. {service}\"\r\n        \r\n        result += f\"\"\"\r\n\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n⏱️ Время маршрутизации: 0.{datetime.now().microsecond // 1000:03d}s\r\n✅ Статус: Маршрутизация успешна\r\n\r\n💡 Запрос будет обработан специализированным агентом с максимальной эффективностью!\r\n\"\"\"\r\n        \r\n        self.log(f\"Routed to {selected_handler} with confidence {confidence:.2f}\")\r\n        return result\r\n    \r\n    def build_tool(self) -> Tool:\r\n        \"\"\"\r\n        Создает Tool для Agent\r\n        \"\"\"\r\n        return Tool(\r\n            name=\"smart_orchestration_router\",\r\n            description=(\r\n                \"🎯 ДЕМОНСТРАЦИОННЫЙ ИНСТРУМЕНТ для визуализации архитектуры! \"\r\n                \"Показывает интеллектуальную маршрутизацию запроса к специализированному обработчику. \"\r\n                \"Используй ТОЛЬКО для первого запроса пользователя или новых вопросов (не для уточнений). \"\r\n                \"Это демонстрация работы микросервисной архитектуры с умной маршрутизацией. \"\r\n                \"НЕ влияет на основную логику обработки запроса! \"\r\n                \"Входной параметр: user_query - запрос пользователя (строка)\"\r\n            ),\r\n            func=self.route_request,\r\n        )"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "SmartOrchestrationRouter"
        },
        "dragging": false,
        "id": "CustomComponent-qRuGK",
        "measured": {
          "height": 137,
          "width": 320
        },
        "position": {
          "x": 3118.9696821799666,
          "y": -641.6254701969314
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "CustomComponent-pznJO",
          "node": {
            "base_classes": [
              "Tool"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Real-time мониторинг статуса микросервисов системы",
            "display_name": "Processing Monitor Tool",
            "documentation": "",
            "edited": true,
            "field_order": [],
            "frozen": false,
            "icon": "activity",
            "legacy": false,
            "lf_version": "1.6.4",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Tool",
                "group_outputs": false,
                "hidden": null,
                "method": "build_tool",
                "name": "tool_output",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.custom import Component\r\nfrom langflow.io import Output\r\nfrom langflow.schema.message import Message\r\nfrom langchain.tools import Tool\r\nfrom typing import Dict\r\nimport random\r\nfrom datetime import datetime\r\n\r\n\r\nclass ProcessingMonitorTool(Component):\r\n    display_name = \"Processing Monitor Tool\"\r\n    description = \"Real-time мониторинг статуса микросервисов системы\"\r\n    icon = \"activity\"\r\n    name = \"ProcessingMonitor\"\r\n    \r\n    outputs = [\r\n        Output(display_name=\"Tool\", name=\"tool_output\", method=\"build_tool\"),\r\n    ]\r\n    \r\n    def generate_service_status(self, service_name: str, operation_type: str) -> Dict:\r\n        \"\"\"Генерирует реалистичный статус микросервиса\"\"\"\r\n        # Определяем, какие сервисы активны в зависимости от типа операции\r\n        active_services = {\r\n            \"Query Processing\": [\"Knowledge Base\", \"NLP Engine\", \"Context Manager\"],\r\n            \"HR Query Processing\": [\"Employee Database\", \"Schedule Manager\", \"Leave Management\"],\r\n            \"IT Support Request\": [\"Identity Management\", \"Access Control\", \"System Monitor\"],\r\n            \"System Action Request\": [\"User Provisioning\", \"Permission Manager\", \"Audit Logger\"],\r\n            \"Technical Query\": [\"Knowledge Base\", \"NLP Engine\", \"Classification Service\"]\r\n        }\r\n        \r\n        is_active = service_name in active_services.get(operation_type, [])\r\n        \r\n        if is_active:\r\n            statuses = [\"🟢 Running\", \"🟡 Processing\"]\r\n            status = random.choice(statuses)\r\n            load = random.randint(30, 85)\r\n            response_time = random.randint(50, 200)\r\n        else:\r\n            status = \"⚪ Idle\"\r\n            load = random.randint(5, 15)\r\n            response_time = random.randint(10, 30)\r\n        \r\n        return {\r\n            \"status\": status,\r\n            \"load\": load,\r\n            \"response_time\": response_time\r\n        }\r\n    \r\n    def show_monitor(self, operation_type: str = \"Query Processing\") -> str:\r\n        \"\"\"\r\n        Показывает real-time статус всех микросервисов\r\n        \"\"\"\r\n        # Определяем микросервисы системы\r\n        microservices = {\r\n            \"Core Services\": [\r\n                \"API Gateway\",\r\n                \"Load Balancer\",\r\n                \"Message Queue\"\r\n            ],\r\n            \"Processing Layer\": [\r\n                \"NLP Engine\",\r\n                \"Context Manager\",\r\n                \"Classification Service\"\r\n            ],\r\n            \"Data Layer\": [\r\n                \"Knowledge Base\",\r\n                \"Employee Database\",\r\n                \"Cache Layer\"\r\n            ],\r\n            \"Business Logic\": [\r\n                \"HR Processor\",\r\n                \"IT Support Handler\",\r\n                \"Request Manager\"\r\n            ],\r\n            \"Infrastructure\": [\r\n                \"Identity Management\",\r\n                \"Access Control\",\r\n                \"Audit Logger\"\r\n            ]\r\n        }\r\n        \r\n        timestamp = datetime.now().strftime(\"%H:%M:%S\")\r\n        \r\n        result = f\"\"\"\r\n╔══════════════════════════════════════════════════════════╗\r\n║        📊 REAL-TIME SYSTEM MONITORING                    ║\r\n╚══════════════════════════════════════════════════════════╝\r\n\r\n⏰ Время: {timestamp}\r\n🔄 Операция: {operation_type}\r\n\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\"\"\"\r\n        \r\n        # Генерируем статус для каждой группы микросервисов\r\n        for category, services in microservices.items():\r\n            result += f\"\\n📦 {category}:\\n\"\r\n            \r\n            for service in services:\r\n                status_info = self.generate_service_status(service, operation_type)\r\n                status_icon = status_info[\"status\"]\r\n                load = status_info[\"load\"]\r\n                response_time = status_info[\"response_time\"]\r\n                \r\n                # Прогресс-бар для нагрузки\r\n                bar_length = int(load / 10)\r\n                load_bar = \"█\" * bar_length + \"░\" * (10 - bar_length)\r\n                \r\n                result += f\"  {status_icon:12} {service:25} │ Load: {load_bar} {load}% │ {response_time}ms\\n\"\r\n        \r\n        # Общая статистика\r\n        avg_load = random.randint(40, 70)\r\n        active_connections = random.randint(50, 200)\r\n        requests_per_second = random.randint(100, 500)\r\n        \r\n        result += f\"\"\"\r\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\r\n\r\n📈 ОБЩАЯ СТАТИСТИКА:\r\n  • Средняя нагрузка системы: {avg_load}%\r\n  • Активных подключений: {active_connections}\r\n  • Запросов в секунду: {requests_per_second}\r\n  • Доступность: 99.9%\r\n\r\n🎯 Система работает в штатном режиме\r\n✅ Все критичные сервисы доступны\r\n\"\"\"\r\n        \r\n        self.log(f\"Monitor displayed for operation: {operation_type}\")\r\n        return result\r\n    \r\n    def build_tool(self) -> Tool:\r\n        \"\"\"\r\n        Создает Tool для Agent\r\n        \"\"\"\r\n        return Tool(\r\n            name=\"show_processing_monitor\",\r\n            description=(\r\n                \"📊 ДЕМОНСТРАЦИОННЫЙ ИНСТРУМЕНТ для визуализации observability! \"\r\n                \"Показывает real-time статус всех микросервисов системы, их нагрузку и время отклика. \"\r\n                \"Используй ТОЛЬКО для первого запроса или новых вопросов (не для уточнений). \"\r\n                \"Это демонстрация мониторинга и наблюдаемости системы. \"\r\n                \"НЕ влияет на основную логику обработки запроса! \"\r\n                \"Входной параметр: operation_type - тип операции (строка, например 'Query Processing', 'HR Query Processing', 'IT Support Request')\"\r\n            ),\r\n            func=self.show_monitor,\r\n        )"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ProcessingMonitor"
        },
        "dragging": false,
        "id": "CustomComponent-pznJO",
        "measured": {
          "height": 137,
          "width": 320
        },
        "position": {
          "x": 3516.5448401449244,
          "y": -664.0897942872358
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": -366.6911665428654,
      "y": 406.4812343913577,
      "zoom": 0.5213930260662072
    }
  },
  "description": "Agent fucntions",
  "endpoint_name": null,
  "id": "0fd7ac61-2489-47a3-97eb-087a594276d9",
  "is_component": false,
  "last_tested_version": "1.6.4",
  "name": "Agentic_flow",
  "tags": [
    "chatbots"
  ]
}